{
  "address": "0xF224E69C461A2dd3c5F6f6814529c8Cf557A1367",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_dStakeCollateralVault",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_dStakeRouter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_dLendRewardsController",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_targetStaticATokenWrapper",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_dLendAssetToClaimFor",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_treasury",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_maxTreasuryFeeBps",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_initialTreasuryFeeBps",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_initialExchangeThreshold",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AccessControlBadConfirmation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "neededRole",
          "type": "bytes32"
        }
      ],
      "name": "AccessControlUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AdapterNotSetForDefaultAsset",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "expected",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "actual",
          "type": "address"
        }
      ],
      "name": "AdapterReturnedUnexpectedAsset",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "AddressEmptyCode",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "AddressInsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DefaultDepositAssetNotSet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "threshold",
          "type": "uint256"
        }
      ],
      "name": "ExchangeAmountTooLow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FailedInnerCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "adapter",
          "type": "address"
        }
      ],
      "name": "InvalidAdapter",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidRouter",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MathOverflowedMulDiv",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "maxTreasuryFeeBps",
          "type": "uint256"
        }
      ],
      "name": "MaxTreasuryFeeTooHigh",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReentrancyGuardReentrantCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "claimedAmountsLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "rewardTokensLength",
          "type": "uint256"
        }
      ],
      "name": "RewardAmountsLengthMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "treasuryFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "rewardAmount",
          "type": "uint256"
        }
      ],
      "name": "TreasuryFeeExceedsRewardAmount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "treasuryFeeBps",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxTreasuryFeeBps",
          "type": "uint256"
        }
      ],
      "name": "TreasuryFeeTooHigh",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroExchangeAssetAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroExchangeThreshold",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroReceiverAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroRewardTokens",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroTreasuryAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldController",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newController",
          "type": "address"
        }
      ],
      "name": "DLendRewardsControllerUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vaultAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vaultAssetAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "dStableCompoundedAmount",
          "type": "uint256"
        }
      ],
      "name": "ExchangeAssetProcessed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldExchangeThreshold",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newExchangeThreshold",
          "type": "uint256"
        }
      ],
      "name": "ExchangeThresholdUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "exchangeAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "rewardTokens",
          "type": "address[]"
        }
      ],
      "name": "RewardCompounded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldTreasuryFeeBps",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newTreasuryFeeBps",
          "type": "uint256"
        }
      ],
      "name": "TreasuryFeeBpsUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldTreasury",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newTreasury",
          "type": "address"
        }
      ],
      "name": "TreasuryUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DEFAULT_ADMIN_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REWARDS_MANAGER_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "rewardTokens",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "compoundRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dLendAssetToClaimFor",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dLendRewardsController",
      "outputs": [
        {
          "internalType": "contract IDLendRewardsController",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dStakeCollateralVault",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dStakeRouter",
      "outputs": [
        {
          "internalType": "contract DStakeRouterDLend",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "exchangeAsset",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "exchangeThreshold",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        }
      ],
      "name": "getRoleAdmin",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getTreasuryFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "grantRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasRole",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxTreasuryFeeBps",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "callerConfirmation",
          "type": "address"
        }
      ],
      "name": "renounceRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "revokeRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newDLendRewardsController",
          "type": "address"
        }
      ],
      "name": "setDLendRewardsController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newExchangeThreshold",
          "type": "uint256"
        }
      ],
      "name": "setExchangeThreshold",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newTreasury",
          "type": "address"
        }
      ],
      "name": "setTreasury",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newTreasuryFeeBps",
          "type": "uint256"
        }
      ],
      "name": "setTreasuryFeeBps",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "targetStaticATokenWrapper",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "treasury",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "treasuryFeeBps",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x9331a9d881490e9d2d5bbe8d92c42ffc16c1ce56c42cec98cb868655abfbf508",
  "receipt": {
    "to": null,
    "from": "0x0f5e3D9AEe7Ab5fDa909Af1ef147D98a7f4B3022",
    "contractAddress": "0xF224E69C461A2dd3c5F6f6814529c8Cf557A1367",
    "transactionIndex": 1,
    "gasUsed": "1412333",
    "logsBloom": "0x00000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000400000000000000000000000000000000000000000000000000000000000000000000020000000000000000000800000000800200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000201000000000000000000000000000000000000000000000000000000000000100000000000020000001000000000000000000000100000000000000000000000000000020000000",
    "blockHash": "0xe3abacf9db8d53a8a446a13ca947a61a11250b458cad033ce70b6e91d0c244da",
    "transactionHash": "0x9331a9d881490e9d2d5bbe8d92c42ffc16c1ce56c42cec98cb868655abfbf508",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 23530227,
        "transactionHash": "0x9331a9d881490e9d2d5bbe8d92c42ffc16c1ce56c42cec98cb868655abfbf508",
        "address": "0xF224E69C461A2dd3c5F6f6814529c8Cf557A1367",
        "topics": [
          "0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f5e3d9aee7ab5fda909af1ef147d98a7f4b3022",
          "0x0000000000000000000000000f5e3d9aee7ab5fda909af1ef147d98a7f4b3022"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xe3abacf9db8d53a8a446a13ca947a61a11250b458cad033ce70b6e91d0c244da"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 23530227,
        "transactionHash": "0x9331a9d881490e9d2d5bbe8d92c42ffc16c1ce56c42cec98cb868655abfbf508",
        "address": "0xF224E69C461A2dd3c5F6f6814529c8Cf557A1367",
        "topics": [
          "0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d",
          "0x51785d261c3b3e8c2cfe2d0e108b9ab2b1fb703ff9e9e49aba4ebdc85c36152b",
          "0x0000000000000000000000000f5e3d9aee7ab5fda909af1ef147d98a7f4b3022",
          "0x0000000000000000000000000f5e3d9aee7ab5fda909af1ef147d98a7f4b3022"
        ],
        "data": "0x",
        "logIndex": 1,
        "blockHash": "0xe3abacf9db8d53a8a446a13ca947a61a11250b458cad033ce70b6e91d0c244da"
      }
    ],
    "blockNumber": 23530227,
    "cumulativeGasUsed": "1458398",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5432ed4A370718D6904485e2Fc114762C68Cc7BE",
    "0xEfc15efb330112a2c313d5da8f1b29893AD4Cd99",
    "0x0E20D018A1309fED73AbdF2187FC452D1DB77915",
    "0xDf697E9608cD286F83d8F76F33a258aC1a8d2764",
    "0x29d0256fe397F6e442464982C4Cba7670646059b",
    "0xfC2f89F9982BE98A9672CEFc3Ea6dBBdd88bc8e9",
    500,
    100,
    "1000000000000000000"
  ],
  "numDeployments": 1,
  "solcInputHash": "3ab0b7ef278db081e26e71c26b8f317e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dStakeCollateralVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dStakeRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dLendRewardsController\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_targetStaticATokenWrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dLendAssetToClaimFor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxTreasuryFeeBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialTreasuryFeeBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialExchangeThreshold\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdapterNotSetForDefaultAsset\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actual\",\"type\":\"address\"}],\"name\":\"AdapterReturnedUnexpectedAsset\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DefaultDepositAssetNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ExchangeAmountTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"InvalidAdapter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MathOverflowedMulDiv\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTreasuryFeeBps\",\"type\":\"uint256\"}],\"name\":\"MaxTreasuryFeeTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedAmountsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardTokensLength\",\"type\":\"uint256\"}],\"name\":\"RewardAmountsLengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"TreasuryFeeExceedsRewardAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treasuryFeeBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTreasuryFeeBps\",\"type\":\"uint256\"}],\"name\":\"TreasuryFeeTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroExchangeAssetAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroExchangeThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroReceiverAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroRewardTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroTreasuryAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldController\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"DLendRewardsControllerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultAssetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dStableCompoundedAmount\",\"type\":\"uint256\"}],\"name\":\"ExchangeAssetProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldExchangeThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExchangeThreshold\",\"type\":\"uint256\"}],\"name\":\"ExchangeThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangeAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"}],\"name\":\"RewardCompounded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTreasuryFeeBps\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTreasuryFeeBps\",\"type\":\"uint256\"}],\"name\":\"TreasuryFeeBpsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldTreasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasuryUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"compoundRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dLendAssetToClaimFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dLendRewardsController\",\"outputs\":[{\"internalType\":\"contract IDLendRewardsController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dStakeCollateralVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dStakeRouter\",\"outputs\":[{\"internalType\":\"contract DStakeRouterDLend\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTreasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTreasuryFeeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDLendRewardsController\",\"type\":\"address\"}],\"name\":\"setDLendRewardsController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newExchangeThreshold\",\"type\":\"uint256\"}],\"name\":\"setExchangeThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTreasuryFeeBps\",\"type\":\"uint256\"}],\"name\":\"setTreasuryFeeBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetStaticATokenWrapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFeeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the RewardClaimable interface.      The caller of `compoundRewards` provides dStable (the exchangeAsset). This contract      then claims specified reward tokens earned by the `targetStaticATokenWrapper`.      The net rewards (after treasury fee) are sent to the receiver specified by the caller.      The initially provided dStable is then converted to the DStakeCollateralVault's      default deposit asset and deposited into the vault.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}],\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}],\"MathOverflowedMulDiv()\":[{\"details\":\"Muldiv operation overflow.\"}],\"ReentrancyGuardReentrantCall()\":[{\"details\":\"Unauthorized reentrant call.\"}],\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC20 token failed.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"getTreasuryFee(uint256)\":{\"details\":\"Calculates the treasury fee for a given amount\",\"params\":{\"amount\":\"The amount to calculate the treasury fee for\"},\"returns\":{\"_0\":\"The treasury fee in the same unit as the amount\"}},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"setDLendRewardsController(address)\":{\"details\":\"Only callable by DEFAULT_ADMIN_ROLE.\",\"params\":{\"_newDLendRewardsController\":\"The address of the new rewards controller.\"}},\"setExchangeThreshold(uint256)\":{\"details\":\"Sets the minimum threshold for exchange operations\",\"params\":{\"newExchangeThreshold\":\"New minimum threshold amount\"}},\"setTreasury(address)\":{\"details\":\"Sets the treasury address\",\"params\":{\"newTreasury\":\"The new treasury address\"}},\"setTreasuryFeeBps(uint256)\":{\"details\":\"Sets the treasury fee in basis points\",\"params\":{\"newTreasuryFeeBps\":\"New treasury fee in basis points (100 = 1bps = 0.01%)\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"title\":\"DStakeRewardManagerDLend\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"compoundRewards(uint256,address[],address)\":{\"notice\":\"Override to deposit exchangeAsset for wrapper positions before claiming rewards and distribute rewards\"},\"setDLendRewardsController(address)\":{\"notice\":\"Sets the address of the dLEND RewardsController contract.\"}},\"notice\":\"Manages claiming of dLEND rewards earned by a specific StaticATokenLM wrapper         (associated with a DStakeCollateralVault) and compounds dStable (provided by a caller)         into the DStakeCollateralVault.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol\":\"DStakeRewardManagerDLend\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts-5/access/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa0e92d42942f4f57c5be50568dac11e9d00c93efcb458026e18d2d9b9b2e7308\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\",\"keccak256\":\"0xb6b36edd6a2999fd243ff226d6cbf84bd71af2432bbd0dfe19392996a1d9cb41\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/interfaces/IERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n */\\ninterface IERC4626 is IERC20, IERC20Metadata {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \\u201cmanaged\\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n     * \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n     * \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\",\"keccak256\":\"0x207f64371bc0fcc5be86713aa5da109a870cc3a6da50e93b64ee881e369b593d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xaa761817f6cd7892fcf158b3c776b34551cde36f48ff9703d53898bc45a94ea2\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x6008dabfe393240d73d7dd7688033f72740d570aa422254d29a7dce8568f3aff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x37bb49513c49c87c4642a891b13b63571bc87013dde806617aa1efb54605f386\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xf980daa263b661ab8ddee7d4fd833c7da7e7995e2c359ff1f17e67e4112f2236\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-5/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value => uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x86c1470cbfd878491e5de030072b647352d36bd27122cffb928970b1945282aa\",\"license\":\"MIT\"},\"contracts/common/BasisPointConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 *\\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\\n *   /\\\\  __-.  /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\ \\\\   /\\\\ \\\"-.\\\\ \\\\   /\\\\ \\\\   /\\\\__  _\\\\ /\\\\ \\\\_\\\\ \\\\      *\\n *   \\\\ \\\\ \\\\/\\\\ \\\\ \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\  \\\\ \\\\ \\\\-.  \\\\  \\\\ \\\\ \\\\  \\\\/_/\\\\ \\\\/ \\\\ \\\\____ \\\\     *\\n *    \\\\ \\\\____-    \\\\ \\\\_\\\\  \\\\ \\\\_\\\\ \\\\_\\\\  \\\\ \\\\_\\\\  \\\\ \\\\_\\\\\\\\\\\"\\\\_\\\\  \\\\ \\\\_\\\\    \\\\ \\\\_\\\\  \\\\/\\\\_____\\\\    *\\n *     \\\\/____/     \\\\/_/   \\\\/_/ /_/   \\\\/_/   \\\\/_/ \\\\/_/   \\\\/_/     \\\\/_/   \\\\/_____/    *\\n *                                                                                  *\\n * \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 dtrinity.org \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 *\\n *                                                                                  *\\n *                                         \\u25b2                                        *\\n *                                        \\u25b2 \\u25b2                                       *\\n *                                                                                  *\\n * \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 *\\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\\n * \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 */\\n\\npragma solidity ^0.8.20;\\n\\nlibrary BasisPointConstants {\\n    // Shared definitions of how we represent percentages and basis points\\n    uint16 public constant ONE_BPS = 100; // 1 basis point with 2 decimals\\n    uint32 public constant ONE_PERCENT_BPS = ONE_BPS * 100;\\n    uint32 public constant ONE_HUNDRED_PERCENT_BPS = ONE_PERCENT_BPS * 100;\\n}\\n\",\"keccak256\":\"0xcaa3c2f2eaf2de426875dafae0956015204c7cf85939010129192c2da4aeb54e\",\"license\":\"MIT\"},\"contracts/vaults/dstake/DStakeCollateralVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts-5/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts-5/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IDStakeCollateralVault} from \\\"./interfaces/IDStakeCollateralVault.sol\\\";\\nimport {IDStableConversionAdapter} from \\\"./interfaces/IDStableConversionAdapter.sol\\\";\\nimport {AccessControl} from \\\"@openzeppelin/contracts-5/access/AccessControl.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts-5/utils/structs/EnumerableSet.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts-5/utils/ReentrancyGuard.sol\\\";\\n\\n// ---------------------------------------------------------------------------\\n// Internal interface to query the router's public mapping without importing the\\n// full router contract (avoids circular dependencies).\\n// ---------------------------------------------------------------------------\\ninterface IAdapterProvider {\\n    function vaultAssetToAdapter(address) external view returns (address);\\n}\\n\\n/**\\n * @title DStakeCollateralVault\\n * @notice Holds various yield-bearing/convertible ERC20 tokens (`vault assets`) managed by dSTAKE.\\n * @dev Calculates the total value of these assets in terms of the underlying dStable asset\\n *      using registered adapters. This contract is non-upgradeable but replaceable via\\n *      DStakeToken governance.\\n *      Uses AccessControl for role-based access control.\\n */\\ncontract DStakeCollateralVault is\\n    IDStakeCollateralVault,\\n    AccessControl,\\n    ReentrancyGuard\\n{\\n    using SafeERC20 for IERC20;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // --- Roles ---\\n    bytes32 public constant ROUTER_ROLE = keccak256(\\\"ROUTER_ROLE\\\");\\n\\n    // --- Errors ---\\n    error ZeroAddress();\\n    error AssetNotSupported(address asset);\\n    error AssetAlreadySupported(address asset);\\n    error NonZeroBalance(address asset);\\n    error CannotRescueRestrictedToken(address token);\\n    error ETHTransferFailed(address receiver, uint256 amount);\\n\\n    // --- Events ---\\n    event TokenRescued(\\n        address indexed token,\\n        address indexed receiver,\\n        uint256 amount\\n    );\\n    event ETHRescued(address indexed receiver, uint256 amount);\\n\\n    // --- State ---\\n    address public immutable dStakeToken; // The DStakeToken this vault serves\\n    address public immutable dStable; // The underlying dStable asset address\\n\\n    address public router; // The DStakeRouter allowed to interact\\n\\n    EnumerableSet.AddressSet private _supportedAssets; // Set of supported vault assets\\n\\n    // --- Constructor ---\\n    constructor(address _dStakeVaultShare, address _dStableAsset) {\\n        if (_dStakeVaultShare == address(0) || _dStableAsset == address(0)) {\\n            revert ZeroAddress();\\n        }\\n        dStakeToken = _dStakeVaultShare;\\n        dStable = _dStableAsset;\\n\\n        // Set up the DEFAULT_ADMIN_ROLE initially to the contract deployer\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    // --- External Views (IDStakeCollateralVault Interface) ---\\n\\n    /**\\n     * @inheritdoc IDStakeCollateralVault\\n     */\\n    function totalValueInDStable()\\n        external\\n        view\\n        override\\n        returns (uint256 dStableValue)\\n    {\\n        uint256 totalValue = 0;\\n        uint256 len = _supportedAssets.length();\\n        for (uint256 i = 0; i < len; i++) {\\n            address vaultAsset = _supportedAssets.at(i);\\n            address adapterAddress = IAdapterProvider(router)\\n                .vaultAssetToAdapter(vaultAsset);\\n\\n            if (adapterAddress == address(0)) {\\n                // If there is no adapter configured, simply skip this asset to\\n                // preserve liveness. Anyone can dust this vault and we cannot\\n                // enforce that all assets have adapters before removal\\n                continue;\\n            }\\n\\n            uint256 balance = IERC20(vaultAsset).balanceOf(address(this));\\n            if (balance > 0) {\\n                totalValue += IDStableConversionAdapter(adapterAddress)\\n                    .assetValueInDStable(vaultAsset, balance);\\n            }\\n        }\\n        return totalValue;\\n    }\\n\\n    // --- External Functions (Router Interactions) ---\\n\\n    /**\\n     * @notice Transfers `amount` of `vaultAsset` from this vault to `recipient`.\\n     * @dev Only callable by the registered router (ROUTER_ROLE).\\n     */\\n    function sendAsset(\\n        address vaultAsset,\\n        uint256 amount,\\n        address recipient\\n    ) external onlyRole(ROUTER_ROLE) {\\n        if (!_isSupported(vaultAsset)) revert AssetNotSupported(vaultAsset);\\n        IERC20(vaultAsset).safeTransfer(recipient, amount);\\n    }\\n\\n    /**\\n     * @notice Adds a new supported vault asset. Can only be invoked by the router.\\n     */\\n    function addSupportedAsset(\\n        address vaultAsset\\n    ) external onlyRole(ROUTER_ROLE) {\\n        if (vaultAsset == address(0)) revert ZeroAddress();\\n        if (_isSupported(vaultAsset)) revert AssetAlreadySupported(vaultAsset);\\n\\n        _supportedAssets.add(vaultAsset);\\n        emit SupportedAssetAdded(vaultAsset);\\n    }\\n\\n    /**\\n     * @notice Removes a supported vault asset. Can only be invoked by the router.\\n     */\\n    function removeSupportedAsset(\\n        address vaultAsset\\n    ) external onlyRole(ROUTER_ROLE) {\\n        if (!_isSupported(vaultAsset)) revert AssetNotSupported(vaultAsset);\\n        // NOTE: Previously this function reverted if the vault still held a\\n        // non-zero balance of the asset, causing a griefing / DoS vector:\\n        // anyone could deposit 1 wei of the token to block removal. The\\n        // check has been removed so governance can always delist an asset.\\n\\n        _supportedAssets.remove(vaultAsset);\\n        emit SupportedAssetRemoved(vaultAsset);\\n    }\\n\\n    // --- Governance Functions ---\\n\\n    /**\\n     * @notice Sets the router address. Grants ROUTER_ROLE to new router and\\n     *         revokes it from the previous router.\\n     */\\n    function setRouter(\\n        address _newRouter\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        if (_newRouter == address(0)) revert ZeroAddress();\\n\\n        // Revoke role from old router\\n        if (router != address(0)) {\\n            _revokeRole(ROUTER_ROLE, router);\\n        }\\n\\n        _grantRole(ROUTER_ROLE, _newRouter);\\n        router = _newRouter;\\n        emit RouterSet(_newRouter);\\n    }\\n\\n    // --- Internal Utilities ---\\n\\n    function _isSupported(address asset) private view returns (bool) {\\n        return _supportedAssets.contains(asset);\\n    }\\n\\n    // --- External Views ---\\n\\n    /**\\n     * @notice Returns the vault asset at `index` from the internal supported set.\\n     *         Kept for backwards-compatibility with the previous public array getter.\\n     */\\n    function supportedAssets(\\n        uint256 index\\n    ) external view override returns (address) {\\n        return _supportedAssets.at(index);\\n    }\\n\\n    /**\\n     * @notice Returns the entire list of supported vault assets. Useful for UIs & off-chain tooling.\\n     */\\n    function getSupportedAssets() external view returns (address[] memory) {\\n        return _supportedAssets.values();\\n    }\\n\\n    // --- Recovery Functions ---\\n\\n    /**\\n     * @notice Rescues tokens accidentally sent to the contract\\n     * @dev Cannot rescue supported vault assets or the dStable token\\n     * @param token Address of the token to rescue\\n     * @param receiver Address to receive the rescued tokens\\n     * @param amount Amount of tokens to rescue\\n     */\\n    function rescueToken(\\n        address token,\\n        address receiver,\\n        uint256 amount\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {\\n        if (receiver == address(0)) revert ZeroAddress();\\n\\n        // Check if token is a supported asset\\n        if (_isSupported(token)) {\\n            revert CannotRescueRestrictedToken(token);\\n        }\\n\\n        // Check if token is the dStable token\\n        if (token == dStable) {\\n            revert CannotRescueRestrictedToken(token);\\n        }\\n\\n        // Rescue the token\\n        IERC20(token).safeTransfer(receiver, amount);\\n        emit TokenRescued(token, receiver, amount);\\n    }\\n\\n    /**\\n     * @notice Rescues ETH accidentally sent to the contract\\n     * @param receiver Address to receive the rescued ETH\\n     * @param amount Amount of ETH to rescue\\n     */\\n    function rescueETH(\\n        address receiver,\\n        uint256 amount\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {\\n        if (receiver == address(0)) revert ZeroAddress();\\n\\n        (bool success, ) = receiver.call{value: amount}(\\\"\\\");\\n        if (!success) revert ETHTransferFailed(receiver, amount);\\n\\n        emit ETHRescued(receiver, amount);\\n    }\\n\\n    /**\\n     * @notice Returns the list of tokens that cannot be rescued\\n     * @return restrictedTokens Array of restricted token addresses\\n     */\\n    function getRestrictedRescueTokens()\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        address[] memory assets = _supportedAssets.values();\\n        address[] memory restrictedTokens = new address[](assets.length + 1);\\n\\n        // Add all supported assets\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            restrictedTokens[i] = assets[i];\\n        }\\n\\n        // Add dStable token\\n        restrictedTokens[assets.length] = dStable;\\n\\n        return restrictedTokens;\\n    }\\n\\n    /**\\n     * @notice Allows the contract to receive ETH\\n     */\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0xbf0202ad717e0f726f64fca4a78081f678ad58da34b4b7e19a51b6359822861b\",\"license\":\"MIT\"},\"contracts/vaults/dstake/DStakeRouterDLend.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts-5/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts-5/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {AccessControl} from \\\"@openzeppelin/contracts-5/access/AccessControl.sol\\\";\\nimport {IDStakeRouter} from \\\"./interfaces/IDStakeRouter.sol\\\";\\nimport {IDStableConversionAdapter} from \\\"./interfaces/IDStableConversionAdapter.sol\\\";\\nimport {IDStakeCollateralVault} from \\\"./DStakeCollateralVault.sol\\\";\\nimport {IERC4626} from \\\"@openzeppelin/contracts-5/interfaces/IERC4626.sol\\\";\\n\\n/**\\n * @title DStakeRouterDLend\\n * @notice Orchestrates deposits, withdrawals, and asset exchanges for a DStakeToken vault.\\n * @dev Interacts with the DStakeToken, DStakeCollateralVault, and various IDStableConversionAdapters.\\n *      This contract is non-upgradeable but replaceable via DStakeToken governance.\\n *      Relies on the associated DStakeToken for role management.\\n */\\ncontract DStakeRouterDLend is IDStakeRouter, AccessControl {\\n    using SafeERC20 for IERC20;\\n\\n    // --- Errors ---\\n    error ZeroAddress();\\n    error AdapterNotFound(address vaultAsset);\\n    error ZeroPreviewWithdrawAmount(address vaultAsset);\\n    error InsufficientDStableFromAdapter(\\n        address vaultAsset,\\n        uint256 expected,\\n        uint256 actual\\n    );\\n    error VaultAssetManagedByDifferentAdapter(\\n        address vaultAsset,\\n        address existingAdapter\\n    );\\n    error ZeroInputDStableValue(address fromAsset, uint256 fromAmount);\\n    error AdapterAssetMismatch(\\n        address adapter,\\n        address expectedAsset,\\n        address actualAsset\\n    );\\n    error SlippageCheckFailed(\\n        address toAsset,\\n        uint256 calculatedAmount,\\n        uint256 minAmount\\n    );\\n    error InconsistentState(string message);\\n\\n    // --- Roles ---\\n    bytes32 public constant DSTAKE_TOKEN_ROLE = keccak256(\\\"DSTAKE_TOKEN_ROLE\\\");\\n    bytes32 public constant COLLATERAL_EXCHANGER_ROLE =\\n        keccak256(\\\"COLLATERAL_EXCHANGER_ROLE\\\");\\n\\n    // --- State ---\\n    address public immutable dStakeToken; // The DStakeToken this router serves\\n    IDStakeCollateralVault public immutable collateralVault; // The DStakeCollateralVault this router serves\\n    address public immutable dStable; // The underlying dSTABLE asset address\\n\\n    // Governance-configurable risk parameters\\n    uint256 public dustTolerance = 1; // 1 wei default tolerance\\n\\n    mapping(address => address) public vaultAssetToAdapter; // vaultAsset => adapterAddress\\n    address public defaultDepositVaultAsset; // Default strategy for deposits\\n\\n    // Struct used to pack local variables in functions prone to \\\"stack too deep\\\" compiler errors\\n    struct ExchangeLocals {\\n        address fromAdapterAddress;\\n        address toAdapterAddress;\\n        IDStableConversionAdapter fromAdapter;\\n        IDStableConversionAdapter toAdapter;\\n        uint256 dStableValueIn;\\n        uint256 calculatedToVaultAssetAmount;\\n    }\\n\\n    // --- Constructor ---\\n    constructor(address _dStakeToken, address _collateralVault) {\\n        if (_dStakeToken == address(0) || _collateralVault == address(0)) {\\n            revert ZeroAddress();\\n        }\\n        dStakeToken = _dStakeToken;\\n        collateralVault = IDStakeCollateralVault(_collateralVault);\\n        dStable = collateralVault.dStable(); // Fetch dStable address from vault\\n        if (dStable == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        // Setup roles\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _grantRole(DSTAKE_TOKEN_ROLE, _dStakeToken);\\n    }\\n\\n    // --- External Functions (IDStakeRouter Interface) ---\\n\\n    /**\\n     * @inheritdoc IDStakeRouter\\n     */\\n    function deposit(\\n        uint256 dStableAmount\\n    ) external override onlyRole(DSTAKE_TOKEN_ROLE) {\\n        address adapterAddress = vaultAssetToAdapter[defaultDepositVaultAsset];\\n        if (adapterAddress == address(0)) {\\n            revert AdapterNotFound(defaultDepositVaultAsset);\\n        }\\n\\n        (\\n            address vaultAssetExpected,\\n            uint256 expectedShares\\n        ) = IDStableConversionAdapter(adapterAddress)\\n                .previewConvertToVaultAsset(dStableAmount);\\n\\n        uint256 mintedShares = _executeDeposit(\\n            adapterAddress,\\n            vaultAssetExpected,\\n            dStableAmount\\n        );\\n\\n        if (mintedShares < expectedShares) {\\n            revert SlippageCheckFailed(\\n                vaultAssetExpected,\\n                mintedShares,\\n                expectedShares\\n            );\\n        }\\n\\n        emit RouterDeposit(\\n            adapterAddress,\\n            vaultAssetExpected,\\n            msg.sender,\\n            mintedShares,\\n            dStableAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs the actual pull-approve-convert sequence and returns the number of shares\\n     *      minted to the collateral vault.\\n     * @param adapterAddress The adapter to use for conversion.\\n     * @param vaultAssetExpected The vault asset that the adapter should mint.\\n     * @param dStableAmount The amount of dStable being deposited.\\n     * @return mintedShares The number of vault asset shares minted.\\n     */\\n    function _executeDeposit(\\n        address adapterAddress,\\n        address vaultAssetExpected,\\n        uint256 dStableAmount\\n    ) private returns (uint256 mintedShares) {\\n        uint256 beforeBal = IERC20(vaultAssetExpected).balanceOf(\\n            address(collateralVault)\\n        );\\n\\n        // Pull dStable from caller (DStakeToken)\\n        IERC20(dStable).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            dStableAmount\\n        );\\n\\n        // Approve adapter to spend dStable\\n        // Use standard approve for trusted protocol token (dStable)\\n        IERC20(dStable).approve(adapterAddress, dStableAmount);\\n\\n        // Convert dStable to vault asset (minted directly to collateral vault)\\n        (\\n            address vaultAssetActual,\\n            uint256 reportedShares\\n        ) = IDStableConversionAdapter(adapterAddress).convertToVaultAsset(\\n                dStableAmount\\n            );\\n\\n        if (vaultAssetActual != vaultAssetExpected) {\\n            revert AdapterAssetMismatch(\\n                adapterAddress,\\n                vaultAssetExpected,\\n                vaultAssetActual\\n            );\\n        }\\n\\n        mintedShares =\\n            IERC20(vaultAssetExpected).balanceOf(address(collateralVault)) -\\n            beforeBal;\\n\\n        if (mintedShares != reportedShares) {\\n            revert InconsistentState(\\\"Adapter mis-reported shares\\\");\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDStakeRouter\\n     */\\n    function withdraw(\\n        uint256 dStableAmount,\\n        address receiver,\\n        address owner\\n    ) external override onlyRole(DSTAKE_TOKEN_ROLE) {\\n        address adapterAddress = vaultAssetToAdapter[defaultDepositVaultAsset];\\n        if (adapterAddress == address(0)) {\\n            revert AdapterNotFound(defaultDepositVaultAsset);\\n        }\\n        IDStableConversionAdapter adapter = IDStableConversionAdapter(\\n            adapterAddress\\n        );\\n\\n        // 1. Determine vault asset and required amount\\n        address vaultAsset = adapter.vaultAsset();\\n        // Use previewConvertFromVaultAsset to get the required vaultAssetAmount for the target dStableAmount\\n        uint256 vaultAssetAmount = IERC4626(vaultAsset).previewWithdraw(\\n            dStableAmount\\n        );\\n        if (vaultAssetAmount == 0) revert ZeroPreviewWithdrawAmount(vaultAsset);\\n\\n        // 2. Pull vaultAsset from collateral vault\\n        collateralVault.sendAsset(vaultAsset, vaultAssetAmount, address(this));\\n\\n        // 3. Approve adapter (use forceApprove for external vault assets)\\n        IERC20(vaultAsset).forceApprove(adapterAddress, vaultAssetAmount);\\n\\n        // 4. Call adapter to convert and send dStable to receiver\\n        // Temporarily transfer to this contract, then forward to receiver if needed\\n        uint256 receivedDStable = adapter.convertFromVaultAsset(\\n            vaultAssetAmount\\n        );\\n\\n        // Sanity check: Ensure adapter returned at least the requested amount\\n        if (receivedDStable < dStableAmount) {\\n            revert InsufficientDStableFromAdapter(\\n                vaultAsset,\\n                dStableAmount,\\n                receivedDStable\\n            );\\n        }\\n\\n        // 5. Transfer ONLY the requested amount to the user\\n        IERC20(dStable).safeTransfer(receiver, dStableAmount);\\n\\n        // 6. If adapter over-delivered, immediately convert the surplus dStable\\n        //    back into vault-asset shares so the value is reflected in\\n        //    totalAssets() for all shareholders.\\n        uint256 surplus = receivedDStable - dStableAmount;\\n        if (surplus > 0) {\\n            // Give the adapter allowance to pull the surplus (standard approve for trusted dStable)\\n            IERC20(dStable).approve(adapterAddress, surplus);\\n\\n            // Attempt to recycle surplus; on failure hold it in the router\\n            try adapter.convertToVaultAsset(surplus) returns (\\n                address mintedAsset,\\n                uint256 /* mintedAmount */\\n            ) {\\n                // Sanity: adapter must mint the same asset we just redeemed from\\n                if (mintedAsset != vaultAsset) {\\n                    revert AdapterAssetMismatch(\\n                        adapterAddress,\\n                        vaultAsset,\\n                        mintedAsset\\n                    );\\n                }\\n            } catch {\\n                // Clear approval in case of revert and keep surplus inside router\\n                IERC20(dStable).approve(adapterAddress, 0);\\n                emit SurplusHeld(surplus);\\n            }\\n            // If success: shares minted directly to collateralVault; surplus value captured\\n        }\\n\\n        emit Withdrawn(\\n            vaultAsset,\\n            vaultAssetAmount,\\n            dStableAmount,\\n            owner,\\n            receiver\\n        );\\n    }\\n\\n    // --- External Functions (Exchange/Rebalance) ---\\n\\n    /**\\n     * @notice Exchanges `fromVaultAssetAmount` of one vault asset for another via their adapters.\\n     * @dev Uses dSTABLE as the intermediary asset. Requires COLLATERAL_EXCHANGER_ROLE.\\n     * @param fromVaultAsset The address of the asset to sell.\\n     * @param toVaultAsset The address of the asset to buy.\\n     * @param fromVaultAssetAmount The amount of the `fromVaultAsset` to exchange.\\n     * @param minToVaultAssetAmount The minimum amount of `toVaultAsset` the solver is willing to accept.\\n     */\\n    function exchangeAssetsUsingAdapters(\\n        address fromVaultAsset,\\n        address toVaultAsset,\\n        uint256 fromVaultAssetAmount,\\n        uint256 minToVaultAssetAmount\\n    ) external onlyRole(COLLATERAL_EXCHANGER_ROLE) {\\n        address fromAdapterAddress = vaultAssetToAdapter[fromVaultAsset];\\n        address toAdapterAddress = vaultAssetToAdapter[toVaultAsset];\\n        if (fromAdapterAddress == address(0))\\n            revert AdapterNotFound(fromVaultAsset);\\n        if (toAdapterAddress == address(0))\\n            revert AdapterNotFound(toVaultAsset);\\n\\n        IDStableConversionAdapter fromAdapter = IDStableConversionAdapter(\\n            fromAdapterAddress\\n        );\\n        IDStableConversionAdapter toAdapter = IDStableConversionAdapter(\\n            toAdapterAddress\\n        );\\n\\n        // 1. Get assets and calculate equivalent dStable amount\\n        uint256 dStableAmountEquivalent = fromAdapter\\n            .previewConvertFromVaultAsset(fromVaultAssetAmount);\\n\\n        // 2. Pull fromVaultAsset from collateral vault\\n        collateralVault.sendAsset(\\n            fromVaultAsset,\\n            fromVaultAssetAmount,\\n            address(this)\\n        );\\n\\n        // 3. Approve fromAdapter (use forceApprove for external vault assets) & Convert fromVaultAsset -> dStable (sent to this router)\\n        IERC20(fromVaultAsset).forceApprove(\\n            fromAdapterAddress,\\n            fromVaultAssetAmount\\n        );\\n        uint256 receivedDStable = fromAdapter.convertFromVaultAsset(\\n            fromVaultAssetAmount\\n        );\\n\\n        // 4. Approve toAdapter (standard approve for trusted dStable) & Convert dStable -> toVaultAsset (sent to collateralVault)\\n        IERC20(dStable).approve(toAdapterAddress, receivedDStable);\\n        (\\n            address actualToVaultAsset,\\n            uint256 resultingToVaultAssetAmount\\n        ) = toAdapter.convertToVaultAsset(receivedDStable);\\n        if (actualToVaultAsset != toVaultAsset) {\\n            revert AdapterAssetMismatch(\\n                toAdapterAddress,\\n                toVaultAsset,\\n                actualToVaultAsset\\n            );\\n        }\\n        // Slippage control: ensure output meets minimum requirement\\n        if (resultingToVaultAssetAmount < minToVaultAssetAmount) {\\n            revert SlippageCheckFailed(\\n                toVaultAsset,\\n                resultingToVaultAssetAmount,\\n                minToVaultAssetAmount\\n            );\\n        }\\n\\n        // --- Underlying value parity check ---\\n        uint256 resultingDStableEquivalent = toAdapter\\n            .previewConvertFromVaultAsset(resultingToVaultAssetAmount);\\n\\n        // Rely on Solidity 0.8 checked arithmetic: if `dustTolerance` is greater than\\n        // `dStableAmountEquivalent`, the subtraction will underflow and the transaction\\n        // will revert automatically. This saves gas compared to a ternary guard.\\n        uint256 minRequiredDStable = dStableAmountEquivalent - dustTolerance;\\n\\n        if (resultingDStableEquivalent < minRequiredDStable) {\\n            revert SlippageCheckFailed(\\n                dStable,\\n                resultingDStableEquivalent,\\n                minRequiredDStable\\n            );\\n        }\\n\\n        emit Exchanged(\\n            fromVaultAsset,\\n            toVaultAsset,\\n            fromVaultAssetAmount,\\n            resultingToVaultAssetAmount,\\n            dStableAmountEquivalent,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @notice Exchanges assets between the collateral vault and an external solver.\\n     * @dev Pulls `fromVaultAsset` from the solver (`msg.sender`) and sends `toVaultAsset` from the vault to the solver.\\n     *      Requires COLLATERAL_EXCHANGER_ROLE.\\n     * @param fromVaultAsset The address of the asset the solver is providing.\\n     * @param toVaultAsset The address of the asset the solver will receive from the vault.\\n     * @param fromVaultAssetAmount The amount of `fromVaultAsset` provided by the solver.\\n     * @param minToVaultAssetAmount The minimum amount of `toVaultAsset` the solver is willing to accept.\\n     */\\n    function exchangeAssets(\\n        address fromVaultAsset,\\n        address toVaultAsset,\\n        uint256 fromVaultAssetAmount,\\n        uint256 minToVaultAssetAmount\\n    ) external onlyRole(COLLATERAL_EXCHANGER_ROLE) {\\n        if (fromVaultAssetAmount == 0) {\\n            revert InconsistentState(\\\"Input amount cannot be zero\\\");\\n        }\\n        if (fromVaultAsset == address(0) || toVaultAsset == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        ExchangeLocals memory locals;\\n\\n        // Resolve adapters\\n        locals.fromAdapterAddress = vaultAssetToAdapter[fromVaultAsset];\\n        locals.toAdapterAddress = vaultAssetToAdapter[toVaultAsset];\\n\\n        if (locals.fromAdapterAddress == address(0))\\n            revert AdapterNotFound(fromVaultAsset);\\n        if (locals.toAdapterAddress == address(0))\\n            revert AdapterNotFound(toVaultAsset);\\n\\n        locals.fromAdapter = IDStableConversionAdapter(\\n            locals.fromAdapterAddress\\n        );\\n        locals.toAdapter = IDStableConversionAdapter(locals.toAdapterAddress);\\n\\n        // Calculate dStable received for the input asset\\n        locals.dStableValueIn = locals.fromAdapter.previewConvertFromVaultAsset(\\n            fromVaultAssetAmount\\n        );\\n        if (locals.dStableValueIn == 0) {\\n            revert ZeroInputDStableValue(fromVaultAsset, fromVaultAssetAmount);\\n        }\\n\\n        // Calculate expected output vault asset amount\\n        (address expectedToAsset, uint256 tmpToAmount) = locals\\n            .toAdapter\\n            .previewConvertToVaultAsset(locals.dStableValueIn);\\n\\n        if (expectedToAsset != toVaultAsset) {\\n            revert AdapterAssetMismatch(\\n                locals.toAdapterAddress,\\n                toVaultAsset,\\n                expectedToAsset\\n            );\\n        }\\n\\n        locals.calculatedToVaultAssetAmount = tmpToAmount;\\n\\n        // Slippage check\\n        if (locals.calculatedToVaultAssetAmount < minToVaultAssetAmount) {\\n            revert SlippageCheckFailed(\\n                toVaultAsset,\\n                locals.calculatedToVaultAssetAmount,\\n                minToVaultAssetAmount\\n            );\\n        }\\n\\n        // --- Asset movements ---\\n\\n        // 1. Pull `fromVaultAsset` from solver to this contract\\n        IERC20(fromVaultAsset).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            fromVaultAssetAmount\\n        );\\n\\n        // 2. Transfer the asset into the collateral vault\\n        IERC20(fromVaultAsset).safeTransfer(\\n            address(collateralVault),\\n            fromVaultAssetAmount\\n        );\\n\\n        // 3. Send the calculated amount of `toVaultAsset` to the solver\\n        collateralVault.sendAsset(\\n            toVaultAsset,\\n            locals.calculatedToVaultAssetAmount,\\n            msg.sender\\n        );\\n\\n        emit Exchanged(\\n            fromVaultAsset,\\n            toVaultAsset,\\n            fromVaultAssetAmount,\\n            locals.calculatedToVaultAssetAmount,\\n            locals.dStableValueIn,\\n            msg.sender\\n        );\\n    }\\n\\n    // --- External Functions (Governance - Managed by Admin) ---\\n\\n    /**\\n     * @notice Adds or updates a conversion adapter for a given vault asset.\\n     * @dev Only callable by an address with DEFAULT_ADMIN_ROLE.\\n     * @param vaultAsset The address of the vault asset.\\n     * @param adapterAddress The address of the new adapter contract.\\n     */\\n    function addAdapter(\\n        address vaultAsset,\\n        address adapterAddress\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        if (adapterAddress == address(0) || vaultAsset == address(0)) {\\n            revert ZeroAddress();\\n        }\\n        address adapterVaultAsset = IDStableConversionAdapter(adapterAddress)\\n            .vaultAsset();\\n        if (adapterVaultAsset != vaultAsset)\\n            revert AdapterAssetMismatch(\\n                adapterAddress,\\n                vaultAsset,\\n                adapterVaultAsset\\n            );\\n        if (\\n            vaultAssetToAdapter[vaultAsset] != address(0) &&\\n            vaultAssetToAdapter[vaultAsset] != adapterAddress\\n        ) {\\n            revert VaultAssetManagedByDifferentAdapter(\\n                vaultAsset,\\n                vaultAssetToAdapter[vaultAsset]\\n            );\\n        }\\n        vaultAssetToAdapter[vaultAsset] = adapterAddress;\\n\\n        // Inform the collateral vault of the new supported asset list (no-op if already added)\\n        try collateralVault.addSupportedAsset(vaultAsset) {} catch {}\\n\\n        emit AdapterSet(vaultAsset, adapterAddress);\\n    }\\n\\n    /**\\n     * @notice Removes a conversion adapter for a given vault asset.\\n     * @dev Only callable by an address with DEFAULT_ADMIN_ROLE.\\n     * @dev Does not automatically migrate funds. Ensure assets managed by this adapter are zero\\n     *      in the collateral vault or migrated via exchangeAssets before calling.\\n     * @param vaultAsset The address of the vault asset to remove.\\n     */\\n    function removeAdapter(\\n        address vaultAsset\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        address adapterAddress = vaultAssetToAdapter[vaultAsset];\\n        if (adapterAddress == address(0)) {\\n            revert AdapterNotFound(vaultAsset);\\n        }\\n        delete vaultAssetToAdapter[vaultAsset];\\n\\n        // Inform the collateral vault to remove supported asset.\\n        collateralVault.removeSupportedAsset(vaultAsset);\\n\\n        emit AdapterRemoved(vaultAsset, adapterAddress);\\n    }\\n\\n    /**\\n     * @notice Sets the default vault asset to use for new deposits.\\n     * @dev Only callable by an address with DEFAULT_ADMIN_ROLE.\\n     * @param vaultAsset The address of the vault asset to set as default.\\n     */\\n    function setDefaultDepositVaultAsset(\\n        address vaultAsset\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        if (vaultAssetToAdapter[vaultAsset] == address(0)) {\\n            revert AdapterNotFound(vaultAsset);\\n        }\\n        defaultDepositVaultAsset = vaultAsset;\\n        emit DefaultDepositVaultAssetSet(vaultAsset);\\n    }\\n\\n    // --- Events ---\\n    event RouterDeposit(\\n        address indexed adapter,\\n        address indexed vaultAsset,\\n        address indexed dStakeToken,\\n        uint256 vaultAssetAmount,\\n        uint256 dStableAmount\\n    );\\n    event Withdrawn(\\n        address indexed vaultAsset,\\n        uint256 vaultAssetAmount,\\n        uint256 dStableAmount,\\n        address owner,\\n        address receiver\\n    );\\n    event Exchanged(\\n        address indexed fromAsset,\\n        address indexed toAsset,\\n        uint256 fromAssetAmount,\\n        uint256 toAssetAmount,\\n        uint256 dStableAmountEquivalent,\\n        address indexed exchanger\\n    );\\n    event AdapterSet(address indexed vaultAsset, address adapterAddress);\\n    event AdapterRemoved(address indexed vaultAsset, address adapterAddress);\\n    event DefaultDepositVaultAssetSet(address indexed vaultAsset);\\n    event DustToleranceSet(uint256 newDustTolerance);\\n    event SurplusHeld(uint256 amount);\\n    event SurplusSwept(uint256 amount, address vaultAsset);\\n\\n    // --- Governance setters ---\\n\\n    /**\\n     * @notice Updates the `dustTolerance` used for value-parity checks.\\n     * @dev Only callable by DEFAULT_ADMIN_ROLE.\\n     * @param _dustTolerance The new tolerance value in wei of dStable.\\n     */\\n    function setDustTolerance(\\n        uint256 _dustTolerance\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        dustTolerance = _dustTolerance;\\n        emit DustToleranceSet(_dustTolerance);\\n    }\\n\\n    /**\\n     * @notice Sweeps any dSTABLE surplus held by the router back into the default vault asset.\\n     * @param maxAmount Maximum amount of dSTABLE to sweep (use 0 to sweep full balance).\\n     */\\n    function sweepSurplus(\\n        uint256 maxAmount\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        uint256 balance = IERC20(dStable).balanceOf(address(this));\\n        if (balance == 0) revert ZeroInputDStableValue(dStable, 0);\\n\\n        uint256 amountToSweep = (maxAmount == 0 || maxAmount > balance)\\n            ? balance\\n            : maxAmount;\\n\\n        address adapterAddress = vaultAssetToAdapter[defaultDepositVaultAsset];\\n        if (adapterAddress == address(0))\\n            revert AdapterNotFound(defaultDepositVaultAsset);\\n\\n        IDStableConversionAdapter adapter = IDStableConversionAdapter(\\n            adapterAddress\\n        );\\n        address vaultAsset = adapter.vaultAsset();\\n\\n        IERC20(dStable).approve(adapterAddress, amountToSweep);\\n        (address mintedAsset, ) = adapter.convertToVaultAsset(amountToSweep);\\n\\n        if (mintedAsset != vaultAsset) {\\n            revert AdapterAssetMismatch(\\n                adapterAddress,\\n                vaultAsset,\\n                mintedAsset\\n            );\\n        }\\n\\n        emit SurplusSwept(amountToSweep, mintedAsset);\\n    }\\n}\\n\",\"keccak256\":\"0x9b9dc6797985994c1584c331428f31ff3357d5203510e91a7c1aa1e0b0b86a38\",\"license\":\"MIT\"},\"contracts/vaults/dstake/interfaces/IDStableConversionAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IDStableConversionAdapter Interface\\n * @notice Interface for contracts that handle the conversion between the core dStable asset\\n *         and a specific yield-bearing or convertible ERC20 token (`vault asset`), as well as\\n *         valuing that `vault asset` in terms of the dStable asset.\\n * @dev Implementations interact with specific protocols (lending pools, DEX LPs, wrappers, etc.).\\n */\\ninterface IDStableConversionAdapter {\\n    /**\\n     * @notice Converts a specified amount of the dStable asset into the specific `vaultAsset`\\n     *         managed by this adapter.\\n     * @dev The adapter MUST pull `dStableAmount` of the dStable asset from the caller (expected to be the Router).\\n     * @dev The resulting `vaultAsset` MUST be sent/deposited/minted directly to the `collateralVault` address provided during adapter setup or retrieved.\\n     * @param dStableAmount The amount of dStable asset to convert.\\n     * @return vaultAsset The address of the specific `vault asset` token managed by this adapter.\\n     * @return vaultAssetAmount The amount of `vaultAsset` generated from the conversion.\\n     */\\n    function convertToVaultAsset(\\n        uint256 dStableAmount\\n    ) external returns (address vaultAsset, uint256 vaultAssetAmount);\\n\\n    /**\\n     * @notice Converts a specific amount of `vaultAsset` back into the dStable asset.\\n     * @dev The adapter MUST pull the required amount of `vaultAsset` from the caller (expected to be the Router).\\n     * @dev The resulting dStable asset MUST be sent to the caller.\\n     * @param vaultAssetAmount The amount of `vaultAsset` to convert.\\n     * @return dStableAmount The amount of dStable asset sent to the caller.\\n     */\\n    function convertFromVaultAsset(\\n        uint256 vaultAssetAmount\\n    ) external returns (uint256 dStableAmount);\\n\\n    /**\\n     * @notice Preview the result of converting a given dStable amount to vaultAsset (without state change).\\n     * @param dStableAmount The amount of dStable asset to preview conversion for.\\n     * @return vaultAsset The address of the specific `vault asset` token managed by this adapter.\\n     * @return vaultAssetAmount The amount of `vaultAsset` that would be received.\\n     */\\n    function previewConvertToVaultAsset(\\n        uint256 dStableAmount\\n    ) external view returns (address vaultAsset, uint256 vaultAssetAmount);\\n\\n    /**\\n     * @notice Preview the result of converting a given vaultAsset amount to dStable (without state change).\\n     * @param vaultAssetAmount The amount of `vaultAsset` to preview conversion for.\\n     * @return dStableAmount The amount of dStable asset that would be received.\\n     */\\n    function previewConvertFromVaultAsset(\\n        uint256 vaultAssetAmount\\n    ) external view returns (uint256 dStableAmount);\\n\\n    /**\\n     * @notice Calculates the value of a given amount of the specific `vaultAsset` managed by this adapter\\n     *         in terms of the dStable asset.\\n     * @param vaultAsset The address of the vault asset token (should match getVaultAsset()). Included for explicitness.\\n     * @param vaultAssetAmount The amount of the `vaultAsset` to value.\\n     * @return dStableValue The equivalent value in the dStable asset.\\n     */\\n    function assetValueInDStable(\\n        address vaultAsset,\\n        uint256 vaultAssetAmount\\n    ) external view returns (uint256 dStableValue);\\n\\n    /**\\n     * @notice Returns the address of the specific `vault asset` token managed by this adapter.\\n     * @return The address of the `vault asset`.\\n     */\\n    function vaultAsset() external view returns (address);\\n}\\n\",\"keccak256\":\"0xce7f578388bde1fa102f6d9abbc3af329458b24fae712c3e86440aa0d0bb1ff8\",\"license\":\"MIT\"},\"contracts/vaults/dstake/interfaces/IDStakeCollateralVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IDStakeCollateralVault Interface\\n * @notice Defines the external functions of the DStakeCollateralVault required by other\\n *         contracts in the dSTAKE system, primarily the DStakeToken.\\n */\\ninterface IDStakeCollateralVault {\\n    /**\\n     * @notice Calculates the total value of all managed `vault assets` held by the vault,\\n     *         denominated in the underlying dStable asset.\\n     * @dev This is typically called by the DStakeToken's `totalAssets()` function.\\n     * @return dStableValue The total value of managed assets in terms of the dStable asset.\\n     */\\n    function totalValueInDStable() external view returns (uint256 dStableValue);\\n\\n    /**\\n     * @notice Returns the address of the underlying dStable asset the vault operates with.\\n     * @return The address of the dStable asset.\\n     */\\n    function dStable() external view returns (address);\\n\\n    /**\\n     * @notice The DStakeToken contract address this vault serves.\\n     */\\n    function dStakeToken() external view returns (address);\\n\\n    /**\\n     * @notice The DStakeRouter contract address allowed to interact.\\n     */\\n    function router() external view returns (address);\\n\\n    /**\\n     * @notice Returns the vault asset at `index` from the internal supported list.\\n     */\\n    function supportedAssets(uint256 index) external view returns (address);\\n\\n    /**\\n     * @notice Returns the entire list of supported vault assets. Convenient for UIs & off-chain analytics.\\n     */\\n    function getSupportedAssets() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Transfers `amount` of `vaultAsset` from this vault to the `recipient`.\\n     * @dev Only callable by the registered router.\\n     * @param vaultAsset The address of the vault asset to send.\\n     * @param amount The amount to send.\\n     * @param recipient The address to receive the asset.\\n     */\\n    function sendAsset(\\n        address vaultAsset,\\n        uint256 amount,\\n        address recipient\\n    ) external;\\n\\n    /**\\n     * @notice Sets the address of the DStakeRouter contract.\\n     * @dev Only callable by an address with the DEFAULT_ADMIN_ROLE.\\n     * @param _newRouter The address of the new router contract.\\n     */\\n    function setRouter(address _newRouter) external;\\n\\n    /**\\n     * @notice Adds a vault asset to the supported list. Callable only by the router.\\n     */\\n    function addSupportedAsset(address vaultAsset) external;\\n\\n    /**\\n     * @notice Removes a vault asset from the supported list. Callable only by the router.\\n     */\\n    function removeSupportedAsset(address vaultAsset) external;\\n\\n    /**\\n     * @notice Emitted when the router address is set.\\n     * @param router The address of the new router.\\n     */\\n    event RouterSet(address indexed router);\\n\\n    /**\\n     * @notice Emitted when a new vault asset is added to the supported list.\\n     */\\n    event SupportedAssetAdded(address indexed vaultAsset);\\n\\n    /**\\n     * @notice Emitted when a vault asset is removed from the supported list.\\n     */\\n    event SupportedAssetRemoved(address indexed vaultAsset);\\n}\\n\",\"keccak256\":\"0xe003cc1c2a3e323c1b9c710f5b69b4e5ac1d30d273aea1ad9fa5e12dc63169c3\",\"license\":\"MIT\"},\"contracts/vaults/dstake/interfaces/IDStakeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IDStakeRouter Interface\\n * @notice Defines the external functions of the DStakeRouter required by the DStakeToken\\n *         for handling deposits and withdrawals.\\n */\\ninterface IDStakeRouter {\\n    /**\\n     * @notice Handles the conversion of deposited dStable asset into a chosen `vaultAsset`\\n     *         and informs the collateral vault.\\n     * @dev Called by `DStakeToken._deposit()` after the token has received the dStable asset.\\n     * @dev The router MUST pull `dStableAmount` from the caller (`DStakeToken`).\\n     * @param dStableAmount The amount of dStable asset deposited by the user into the DStakeToken.\\n     */\\n    function deposit(uint256 dStableAmount) external;\\n\\n    /**\\n     * @notice Handles the conversion of a `vaultAsset` back into the dStable asset for withdrawal.\\n     * @dev Called by `DStakeToken._withdraw()`.\\n     * @dev The router coordinates pulling the required `vaultAsset` from the collateral vault\\n     *      and ensuring the converted dStable asset is sent to the `receiver`.\\n     * @param dStableAmount The amount of dStable asset to be withdrawn to the `receiver` (after vault fees).\\n     * @param receiver The address that will receive the withdrawn dStable asset.\\n     * @param owner The original owner initiating the withdrawal (typically the user burning shares).\\n     */\\n    function withdraw(\\n        uint256 dStableAmount,\\n        address receiver,\\n        address owner\\n    ) external;\\n}\\n\",\"keccak256\":\"0x38af14256145092463574eebbf584e9790aca0ba02f85007d61cb33c3fa96f07\",\"license\":\"MIT\"},\"contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {RewardClaimable} from \\\"../../rewards_claimable/RewardClaimable.sol\\\";\\nimport {DStakeRouterDLend} from \\\"../DStakeRouterDLend.sol\\\";\\nimport {IDStakeCollateralVault} from \\\"../interfaces/IDStakeCollateralVault.sol\\\";\\nimport {IDStableConversionAdapter} from \\\"../interfaces/IDStableConversionAdapter.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts-5/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts-5/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n// Interface for the Aave/dLEND RewardsController\\ninterface IDLendRewardsController {\\n    function claimRewardsOnBehalf(\\n        address[] calldata assets,\\n        uint256 amount,\\n        address user,\\n        address to,\\n        address reward\\n    ) external returns (uint256);\\n\\n    function setClaimer(address user, address claimer) external;\\n}\\n\\n/**\\n * @title DStakeRewardManagerDLend\\n * @notice Manages claiming of dLEND rewards earned by a specific StaticATokenLM wrapper\\n *         (associated with a DStakeCollateralVault) and compounds dStable (provided by a caller)\\n *         into the DStakeCollateralVault.\\n * @dev Implements the RewardClaimable interface.\\n *      The caller of `compoundRewards` provides dStable (the exchangeAsset). This contract\\n *      then claims specified reward tokens earned by the `targetStaticATokenWrapper`.\\n *      The net rewards (after treasury fee) are sent to the receiver specified by the caller.\\n *      The initially provided dStable is then converted to the DStakeCollateralVault's\\n *      default deposit asset and deposited into the vault.\\n */\\ncontract DStakeRewardManagerDLend is RewardClaimable {\\n    using SafeERC20 for IERC20;\\n\\n    // --- State ---\\n    address public immutable dStakeCollateralVault; // The ultimate beneficiary vault\\n    DStakeRouterDLend public immutable dStakeRouter;\\n    IDLendRewardsController public dLendRewardsController; // Settable by admin\\n    address public immutable targetStaticATokenWrapper; // The StaticATokenLM instance earning rewards\\n    address public immutable dLendAssetToClaimFor; // The actual aToken in dLEND held by the wrapper\\n\\n    // --- Events ---\\n    event DLendRewardsControllerUpdated(\\n        address oldController,\\n        address newController\\n    );\\n    event ExchangeAssetProcessed(\\n        address indexed vaultAsset,\\n        uint256 vaultAssetAmount,\\n        uint256 dStableCompoundedAmount\\n    );\\n\\n    // --- Errors ---\\n    error InvalidRouter();\\n    error InvalidAdapter(address adapter);\\n    error AdapterReturnedUnexpectedAsset(address expected, address actual);\\n    error DefaultDepositAssetNotSet();\\n    error AdapterNotSetForDefaultAsset();\\n    // Errors also used/defined in RewardClaimable but declared here for clarity if inherited versions are not picked up\\n    error ZeroAddress();\\n\\n    // --- Constructor ---\\n    constructor(\\n        address _dStakeCollateralVault,\\n        address _dStakeRouter,\\n        address _dLendRewardsController,\\n        address _targetStaticATokenWrapper,\\n        address _dLendAssetToClaimFor,\\n        address _treasury,\\n        uint256 _maxTreasuryFeeBps,\\n        uint256 _initialTreasuryFeeBps,\\n        uint256 _initialExchangeThreshold\\n    )\\n        RewardClaimable(\\n            IDStakeCollateralVault(_dStakeCollateralVault).dStable(), // exchangeAsset is dStable\\n            _treasury,\\n            _maxTreasuryFeeBps,\\n            _initialTreasuryFeeBps,\\n            _initialExchangeThreshold\\n        )\\n    {\\n        if (\\n            _dStakeCollateralVault == address(0) ||\\n            _dStakeRouter == address(0) ||\\n            _dLendRewardsController == address(0) ||\\n            _targetStaticATokenWrapper == address(0) ||\\n            _dLendAssetToClaimFor == address(0)\\n        ) {\\n            revert ZeroAddress();\\n        }\\n        if (exchangeAsset == address(0)) {\\n            revert InvalidRouter(); // dStable from collateral vault was zero, or vault address was wrong\\n        }\\n\\n        dStakeCollateralVault = _dStakeCollateralVault;\\n        dStakeRouter = DStakeRouterDLend(_dStakeRouter);\\n        dLendRewardsController = IDLendRewardsController(\\n            _dLendRewardsController\\n        );\\n        targetStaticATokenWrapper = _targetStaticATokenWrapper;\\n        dLendAssetToClaimFor = _dLendAssetToClaimFor;\\n\\n        // Grant roles to deployer\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _grantRole(REWARDS_MANAGER_ROLE, msg.sender);\\n    }\\n\\n    // --- RewardClaimable Overrides ---\\n\\n    /**\\n     * @inheritdoc RewardClaimable\\n     * @dev Claims specified reward tokens from dLEND on behalf of the\\n     *      `targetStaticATokenWrapper` and forwards them to\\n     *      `_receiverForClaimedRawRewards` (usually `address(this)` when invoked\\n     *      from `compoundRewards`).\\n     *\\n     * === Important note about how rewards are claimed ===\\n     * A public call to `StaticATokenLM.collectAndUpdateRewards()` does **not**\\n     * lock tokens inside the wrapper forever.  The wrapper merely holds those\\n     * tokens in its own balance until a legitimate claimer shows up.\\n     *\\n     * When this reward-manager executes\\n     * `IStaticATokenLM.claimRewardsOnBehalf(dStakeCollateralVault, \\u2026)` the\\n     * wrapper performs the following actions internally (see\\n     * `StaticATokenLM._claimRewardsOnBehalf` in the Aave reference\\n     * implementation):\\n     *   1. If the wrapper's ERC20 balance is insufficient to pay the user's\\n     *      owed rewards it first calls `collectAndUpdateRewards()` itself,\\n     *      pulling fresh emissions from the RewardsController.\\n     *   2. It then transfers *all* rewards owed to the user (`to` parameter).\\n     *\\n     * Critically, the payout uses the wrapper's **entire token balance** \\u2013 this\\n     * includes any tokens that were previously moved there by an external\\n     * `collectAndUpdateRewards` call.  Therefore no permanent loss occurs: the\\n     * next compounding round will withdraw those tokens and distribute them\\n     * according to protocol rules.\\n     */\\n    function _claimRewards(\\n        address[] calldata _tokensToClaim,\\n        address _receiverForClaimedRawRewards\\n    ) internal virtual override returns (uint256[] memory rewardAmounts) {\\n        if (_tokensToClaim.length == 0) {\\n            revert ZeroRewardTokens();\\n        }\\n        if (_receiverForClaimedRawRewards == address(0)) {\\n            revert ZeroReceiverAddress();\\n        }\\n\\n        rewardAmounts = new uint256[](_tokensToClaim.length);\\n        address[] memory assetsToClaimForPayload = new address[](1);\\n        assetsToClaimForPayload[0] = dLendAssetToClaimFor;\\n\\n        for (uint256 i = 0; i < _tokensToClaim.length; i++) {\\n            address rewardToken = _tokensToClaim[i];\\n            if (rewardToken == address(0)) {\\n                revert ZeroAddress(); // Cannot claim zero address token\\n            }\\n\\n            uint256 balanceBefore = IERC20(rewardToken).balanceOf(\\n                _receiverForClaimedRawRewards\\n            );\\n\\n            // Claim all available amount of the specific reward token\\n            dLendRewardsController.claimRewardsOnBehalf(\\n                assetsToClaimForPayload, // Asset held by the wrapper in dLEND\\n                type(uint256).max, // Claim all\\n                targetStaticATokenWrapper, // User earning rewards is the wrapper\\n                _receiverForClaimedRawRewards,\\n                rewardToken // The reward token to claim\\n            );\\n\\n            uint256 balanceAfter = IERC20(rewardToken).balanceOf(\\n                _receiverForClaimedRawRewards\\n            );\\n            rewardAmounts[i] = balanceAfter - balanceBefore;\\n        }\\n        return rewardAmounts;\\n    }\\n\\n    /**\\n     * @inheritdoc RewardClaimable\\n     * @dev Processes the dStable (exchangeAsset) provided by the caller of `compoundRewards`.\\n     *      This dStable is converted into the DStakeCollateralVault's default deposit asset\\n     *      via the DStakeRouter and an appropriate adapter, and then deposited into the vault.\\n     *      The adapter is expected to transfer the compounded asset directly to dStakeCollateralVault.\\n     */\\n    function _processExchangeAssetDeposit(\\n        uint256 amountDStableToCompound\\n    ) internal virtual override {\\n        if (amountDStableToCompound == 0) {\\n            // RewardClaimable base function checks amount >= exchangeThreshold, implying amount > 0.\\n            return;\\n        }\\n\\n        address defaultVaultAsset = dStakeRouter.defaultDepositVaultAsset();\\n        if (defaultVaultAsset == address(0)) {\\n            revert DefaultDepositAssetNotSet();\\n        }\\n\\n        address adapterAddress = dStakeRouter.vaultAssetToAdapter(\\n            defaultVaultAsset\\n        );\\n        if (adapterAddress == address(0)) {\\n            revert AdapterNotSetForDefaultAsset();\\n        }\\n\\n        IDStableConversionAdapter adapter = IDStableConversionAdapter(\\n            adapterAddress\\n        );\\n\\n        // Approve the adapter to spend the dStable held by this contract\\n        // Use standard approve for trusted protocol token (dStable/exchangeAsset)\\n        IERC20(exchangeAsset).approve(adapterAddress, amountDStableToCompound);\\n\\n        // The adapter's convertToVaultAsset function is expected to:\\n        // 1. Pull `amountDStableToCompound` from this contract (msg.sender).\\n        // 2. Convert it to `defaultVaultAsset`.\\n        // 3. Deposit/transfer the `defaultVaultAsset` directly to the `dStakeCollateralVault`.\\n        (\\n            address convertedVaultAsset,\\n            uint256 convertedVaultAssetAmount\\n        ) = adapter.convertToVaultAsset(amountDStableToCompound);\\n\\n        if (convertedVaultAsset != defaultVaultAsset) {\\n            revert AdapterReturnedUnexpectedAsset(\\n                defaultVaultAsset,\\n                convertedVaultAsset\\n            );\\n        }\\n\\n        emit ExchangeAssetProcessed(\\n            convertedVaultAsset,\\n            convertedVaultAssetAmount,\\n            amountDStableToCompound\\n        );\\n    }\\n\\n    /**\\n     * @notice Override to deposit exchangeAsset for wrapper positions before claiming rewards and distribute rewards\\n     */\\n    function compoundRewards(\\n        uint256 amount,\\n        address[] calldata rewardTokens,\\n        address receiver\\n    ) public override nonReentrant {\\n        // Validate input\\n        if (amount < exchangeThreshold) {\\n            revert ExchangeAmountTooLow(amount, exchangeThreshold);\\n        }\\n        if (receiver == address(0)) {\\n            revert ZeroReceiverAddress();\\n        }\\n        if (rewardTokens.length == 0) {\\n            revert ZeroRewardTokens();\\n        }\\n\\n        // Transfer the exchange asset from the caller to this contract\\n        IERC20(exchangeAsset).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n\\n        // Deposit exchange asset to collateral vault to establish wrapper positions\\n        _processExchangeAssetDeposit(amount);\\n\\n        // Emit compound event\\n        emit RewardCompounded(exchangeAsset, amount, rewardTokens);\\n\\n        // Claim rewards from dLEND\\n        uint256[] memory rewardAmounts = _claimRewards(\\n            rewardTokens,\\n            address(this)\\n        );\\n\\n        if (rewardAmounts.length != rewardTokens.length) {\\n            revert RewardAmountsLengthMismatch(\\n                rewardAmounts.length,\\n                rewardTokens.length\\n            );\\n        }\\n\\n        // Distribute rewards: fee to treasury, net to receiver\\n        for (uint256 i = 0; i < rewardTokens.length; ++i) {\\n            uint256 rewardAmount = rewardAmounts[i];\\n            uint256 treasuryFee = getTreasuryFee(rewardAmount);\\n            if (treasuryFee > rewardAmount) {\\n                revert TreasuryFeeExceedsRewardAmount(\\n                    treasuryFee,\\n                    rewardAmount\\n                );\\n            }\\n            IERC20(rewardTokens[i]).safeTransfer(treasury, treasuryFee);\\n            IERC20(rewardTokens[i]).safeTransfer(\\n                receiver,\\n                rewardAmount - treasuryFee\\n            );\\n        }\\n    }\\n\\n    // --- Admin Functions ---\\n\\n    /**\\n     * @notice Sets the address of the dLEND RewardsController contract.\\n     * @dev Only callable by DEFAULT_ADMIN_ROLE.\\n     * @param _newDLendRewardsController The address of the new rewards controller.\\n     */\\n    function setDLendRewardsController(\\n        address _newDLendRewardsController\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        if (_newDLendRewardsController == address(0)) {\\n            revert ZeroAddress();\\n        }\\n        address oldController = address(dLendRewardsController);\\n        dLendRewardsController = IDLendRewardsController(\\n            _newDLendRewardsController\\n        );\\n        emit DLendRewardsControllerUpdated(\\n            oldController,\\n            _newDLendRewardsController\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x9481d7c826203124540c4bf02f11b19a802f69475210ad17360cd9a9cb2ae7b3\",\"license\":\"MIT\"},\"contracts/vaults/rewards_claimable/RewardClaimable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/* \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 *\\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\\n *   /\\\\  __-.  /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\ \\\\   /\\\\ \\\"-.\\\\ \\\\   /\\\\ \\\\   /\\\\__  _\\\\ /\\\\ \\\\_\\\\ \\\\      *\\n *   \\\\ \\\\ \\\\/\\\\ \\\\ \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\  \\\\ \\\\ \\\\-.  \\\\  \\\\ \\\\ \\\\  \\\\/_/\\\\ \\\\/ \\\\ \\\\____ \\\\     *\\n *    \\\\ \\\\____-    \\\\ \\\\_\\\\  \\\\ \\\\_\\\\ \\\\_\\\\  \\\\ \\\\_\\\\  \\\\ \\\\_\\\\\\\\\\\"\\\\_\\\\  \\\\ \\\\_\\\\    \\\\ \\\\_\\\\  \\\\/\\\\_____\\\\    *\\n *     \\\\/____/     \\\\/_/   \\\\/_/ /_/   \\\\/_/   \\\\/_/ \\\\/_/   \\\\/_/     \\\\/_/   \\\\/_____/    *\\n *                                                                                  *\\n * \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 dtrinity.org \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 *\\n *                                                                                  *\\n *                                         \\u25b2                                        *\\n *                                        \\u25b2 \\u25b2                                       *\\n *                                                                                  *\\n * \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 *\\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\\n * \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014 */\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts-5/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts-5/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-5/utils/ReentrancyGuard.sol\\\";\\nimport {BasisPointConstants} from \\\"contracts/common/BasisPointConstants.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts-5/utils/math/Math.sol\\\";\\n\\n/**\\n * @title RewardClaimable\\n * @dev Abstract contract for vaults with claimable rewards\\n * Implements functionality for claiming and compounding rewards\\n */\\nabstract contract RewardClaimable is AccessControl, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    // Roles\\n    bytes32 public constant REWARDS_MANAGER_ROLE =\\n        keccak256(\\\"REWARDS_MANAGER_ROLE\\\");\\n\\n    // State variables\\n    address public treasury;\\n    uint256 public treasuryFeeBps;\\n    uint256 public exchangeThreshold;\\n    address public immutable exchangeAsset;\\n    uint256 public immutable maxTreasuryFeeBps;\\n\\n    // Events\\n    event TreasuryUpdated(address oldTreasury, address newTreasury);\\n    event TreasuryFeeBpsUpdated(\\n        uint256 oldTreasuryFeeBps,\\n        uint256 newTreasuryFeeBps\\n    );\\n    event ExchangeThresholdUpdated(\\n        uint256 oldExchangeThreshold,\\n        uint256 newExchangeThreshold\\n    );\\n    event RewardCompounded(\\n        address exchangeAsset,\\n        uint256 amount,\\n        address[] rewardTokens\\n    );\\n\\n    // Custom errors\\n    error ExchangeAmountTooLow(uint256 amount, uint256 threshold);\\n    error RewardAmountsLengthMismatch(\\n        uint256 claimedAmountsLength,\\n        uint256 rewardTokensLength\\n    );\\n    error TreasuryFeeExceedsRewardAmount(\\n        uint256 treasuryFee,\\n        uint256 rewardAmount\\n    );\\n    error ZeroExchangeAssetAddress();\\n    error ZeroTreasuryAddress();\\n    error MaxTreasuryFeeTooHigh(uint256 maxTreasuryFeeBps);\\n    error TreasuryFeeTooHigh(uint256 treasuryFeeBps, uint256 maxTreasuryFeeBps);\\n    error ZeroExchangeThreshold();\\n    error ZeroReceiverAddress();\\n    error ZeroRewardTokens();\\n\\n    /**\\n     * @dev Constructor for the RewardClaimable contract\\n     * @param _exchangeAsset The address of the exchange asset\\n     * @param _treasury The address of the treasury\\n     * @param _maxTreasuryFeeBps The maximum treasury fee in basis points (30000 = 3%), where 100 = 1bps (1e2 for decimals)\\n     * @param _initialTreasuryFeeBps The initial treasury fee in basis points (100 = 1bps, 10000 = 100bps = 1%)\\n     * @param _initialExchangeThreshold The initial minimum threshold amount (in the same unit as the exchange asset)\\n     */\\n    constructor(\\n        address _exchangeAsset,\\n        address _treasury,\\n        uint256 _maxTreasuryFeeBps,\\n        uint256 _initialTreasuryFeeBps,\\n        uint256 _initialExchangeThreshold\\n    ) {\\n        if (_exchangeAsset == address(0)) {\\n            revert ZeroExchangeAssetAddress();\\n        }\\n        if (_treasury == address(0)) {\\n            revert ZeroTreasuryAddress();\\n        }\\n        // The fee cannot exceed the reward amount (100%)\\n        if (_maxTreasuryFeeBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\\n            revert MaxTreasuryFeeTooHigh(_maxTreasuryFeeBps);\\n        }\\n        // The initial fee cannot exceed the max fee, which means cannot be greater than 100% as well\\n        if (_initialTreasuryFeeBps > _maxTreasuryFeeBps) {\\n            revert TreasuryFeeTooHigh(\\n                _initialTreasuryFeeBps,\\n                _maxTreasuryFeeBps\\n            );\\n        }\\n        if (_initialExchangeThreshold == 0) {\\n            revert ZeroExchangeThreshold();\\n        }\\n\\n        exchangeAsset = _exchangeAsset;\\n        treasury = _treasury;\\n        maxTreasuryFeeBps = _maxTreasuryFeeBps;\\n        treasuryFeeBps = _initialTreasuryFeeBps;\\n        exchangeThreshold = _initialExchangeThreshold;\\n\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _grantRole(REWARDS_MANAGER_ROLE, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Sets the treasury address\\n     * @param newTreasury The new treasury address\\n     */\\n    function setTreasury(\\n        address newTreasury\\n    ) external onlyRole(REWARDS_MANAGER_ROLE) {\\n        if (newTreasury == address(0)) {\\n            revert ZeroTreasuryAddress();\\n        }\\n        address oldTreasury = treasury;\\n        treasury = newTreasury;\\n\\n        emit TreasuryUpdated(oldTreasury, newTreasury);\\n    }\\n\\n    /**\\n     * @dev Sets the treasury fee in basis points\\n     * @param newTreasuryFeeBps New treasury fee in basis points (100 = 1bps = 0.01%)\\n     */\\n    function setTreasuryFeeBps(\\n        uint256 newTreasuryFeeBps\\n    ) external onlyRole(REWARDS_MANAGER_ROLE) {\\n        if (newTreasuryFeeBps > maxTreasuryFeeBps) {\\n            revert TreasuryFeeTooHigh(newTreasuryFeeBps, maxTreasuryFeeBps);\\n        }\\n\\n        uint256 oldTreasuryFeeBps = treasuryFeeBps;\\n        treasuryFeeBps = newTreasuryFeeBps;\\n\\n        emit TreasuryFeeBpsUpdated(oldTreasuryFeeBps, newTreasuryFeeBps);\\n    }\\n\\n    /**\\n     * @dev Sets the minimum threshold for exchange operations\\n     * @param newExchangeThreshold New minimum threshold amount\\n     */\\n    function setExchangeThreshold(\\n        uint256 newExchangeThreshold\\n    ) external onlyRole(REWARDS_MANAGER_ROLE) {\\n        if (newExchangeThreshold == 0) {\\n            revert ZeroExchangeThreshold();\\n        }\\n        uint256 oldExchangeThreshold = exchangeThreshold;\\n        exchangeThreshold = newExchangeThreshold;\\n\\n        emit ExchangeThresholdUpdated(\\n            oldExchangeThreshold,\\n            newExchangeThreshold\\n        );\\n    }\\n\\n    /**\\n     * @dev Calculates the treasury fee for a given amount\\n     * @param amount The amount to calculate the treasury fee for\\n     * @return The treasury fee in the same unit as the amount\\n     */\\n    function getTreasuryFee(uint256 amount) public view returns (uint256) {\\n        return\\n            Math.mulDiv(\\n                amount,\\n                treasuryFeeBps,\\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS\\n            );\\n    }\\n\\n    /**\\n     * @dev Compounds multiple rewards\\n     * @param amount The amount to compound\\n     * @param rewardTokens The reward tokens to claim\\n     * @param receiver The address to receive the compounded rewards\\n     */\\n    function compoundRewards(\\n        uint256 amount,\\n        address[] calldata rewardTokens,\\n        address receiver\\n    ) public virtual nonReentrant {\\n        if (amount < exchangeThreshold) {\\n            revert ExchangeAmountTooLow(amount, exchangeThreshold);\\n        }\\n        if (receiver == address(0)) {\\n            revert ZeroReceiverAddress();\\n        }\\n        if (rewardTokens.length == 0) {\\n            revert ZeroRewardTokens();\\n        }\\n\\n        // Transfer the exchange asset from the caller to the vault\\n        IERC20(exchangeAsset).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n\\n        // Emit the event before the internal call to avoid reentrancy\\n        emit RewardCompounded(exchangeAsset, amount, rewardTokens);\\n\\n        // Claim the rewards\\n        uint256[] memory rewardAmounts = _claimRewards(\\n            rewardTokens,\\n            address(this)\\n        );\\n\\n        if (rewardAmounts.length != rewardTokens.length) {\\n            revert RewardAmountsLengthMismatch(\\n                rewardAmounts.length,\\n                rewardTokens.length\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\n            uint256 rewardAmount = rewardAmounts[i];\\n            uint256 treasuryFee = getTreasuryFee(rewardAmount);\\n\\n            // Overflow protection\\n            if (treasuryFee > rewardAmount) {\\n                revert TreasuryFeeExceedsRewardAmount(\\n                    treasuryFee,\\n                    rewardAmount\\n                );\\n            }\\n\\n            // Transfer the treasury fee to the treasury\\n            IERC20(rewardTokens[i]).safeTransfer(treasury, treasuryFee);\\n\\n            // Transfer the remaining amount to the caller\\n            IERC20(rewardTokens[i]).safeTransfer(\\n                receiver,\\n                rewardAmount - treasuryFee\\n            );\\n        }\\n\\n        // Process the exchange asset deposit\\n        _processExchangeAssetDeposit(amount);\\n    }\\n\\n    /**\\n     * @dev Claims multiple rewards\\n     * @param rewardTokens The reward tokens to claim\\n     * @param receiver The address to receive the claimed rewards\\n     * @return rewardAmounts The amount of rewards claimed for each token (have the same length as the tokens array)\\n     */\\n    function _claimRewards(\\n        address[] calldata rewardTokens,\\n        address receiver\\n    ) internal virtual returns (uint256[] memory rewardAmounts);\\n\\n    /**\\n     * @dev Processes the exchange asset deposit from the caller\\n     * @param amount The amount of exchange asset to deposit\\n     */\\n    function _processExchangeAssetDeposit(uint256 amount) internal virtual;\\n}\\n\",\"keccak256\":\"0xe299e0decaaab8482ffb252881299e77b4f9e51b2dc657872bd7ad242b47c385\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x610140604081815234620002fc578190620019f6803803809162000024828662000315565b843961012092839181010312620002fc5762000040836200034f565b6200004e602085016200034f565b6200005b8386016200034f565b916200006a606087016200034f565b9162000079608088016200034f565b936200008860a089016200034f565b60c089015160e08a01516101009a8b015189516306617c6960e11b8152966001600160a01b0396949093600493888616939290919060208b8781885afa9a8b156200030a5760009b620002c1575b5060018055898b1615620002b1578916998a15620002a157620f424082116200028a578183116200026c5783156200025c57608052600280546001600160a01b0319908116909b17905560a0526003558255620001333362000364565b506200013f33620003e4565b5015801562000251575b801562000246575b80156200023b575b801562000230575b620002225784608051161562000214575090839160c0521660e0521690600554161760055584528252620001953362000364565b50620001a133620003e4565b50519061154f9283620004878439608051838181610516015281816106b2015281816106fa0152611133015260a05183818161046f0152610c76015260c051836104d1015260e051838181610be201526110820152518281816102a701526109b50152518181816107e20152610d780152f35b885163466d7fef60e01b8152fd5b885163d92e233d60e01b8152fd5b508488161562000161565b508487161562000159565b508484161562000151565b508483161562000149565b8d516354a62ce560e01b81528690fd5b508c51636cef961f60e11b8152808601929092526024820152604490fd5b50846024918e519163a7519f3f60e01b8352820152fd5b8d516351dc806d60e11b81528690fd5b8d51631810b12760e21b81528690fd5b909a506020813d60201162000301575b81620002e06020938362000315565b81010312620002fc57620002f4906200034f565b9938620000d6565b600080fd5b3d9150620002d1565b8e513d6000823e3d90fd5b601f909101601f19168101906001600160401b038211908210176200033957604052565b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b0382168203620002fc57565b6001600160a01b031660008181527fad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5602052604081205490919060ff16620003e057818052816020526040822081835260205260408220600160ff198254161790553391600080516020620019d68339815191528180a4600190565b5090565b6001600160a01b031660008181527ff6c17da3865d9645546db4630d07c45803fb99f9b61dd452de8de1cd2159d25460205260408120549091907f51785d261c3b3e8c2cfe2d0e108b9ab2b1fb703ff9e9e49aba4ebdc85c36152b9060ff166200048157808352826020526040832082845260205260408320600160ff19825416179055600080516020620019d6833981519152339380a4600190565b50509056fe608080604052600436101561001357600080fd5b60003560e01c90816301ffc9a714610da7575080631f52be6414610d62578063248a9ca314610d335780632f2ff15d14610cf4578063331fb00f14610c5857806336568abe14610c115780633c9f23f014610bcc5780634603be6f146105d057806349b40402146105b257806356d1d4a2146105455780635898ec3b1461050057806358a87913146104bb57806361d027b3146104925780637dd38d9a1461045757806391d148541461040a578063a1b2736a1461031b578063a217fddf146102ff578063acfec690146102d6578063ae37f47914610291578063d547741f14610250578063e0dd245714610215578063e80cfa5e146101f7578063eaff4592146101ce5763f0f442601461012757600080fd5b346101c95760203660031901126101c957610140610e10565b610148610e81565b6001600160a01b0381811680156101b757600280546001600160a01b031981169092179055604080516001600160a01b0393909216831682529190921660208301527f4ab5be82436d353e61ca18726e984e561f5c1cc7c6d38b29d2553c790434705a9190819081015b0390a1005b6040516351dc806d60e11b8152600490fd5b600080fd5b346101c95760203660031901126101c95760206101ef600354600435611373565b604051908152f35b346101c95760003660031901126101c9576020600354604051908152f35b346101c95760003660031901126101c95760206040517f51785d261c3b3e8c2cfe2d0e108b9ab2b1fb703ff9e9e49aba4ebdc85c36152b8152f35b346101c95760403660031901126101c95761028f60043561026f610dfa565b9080600052600060205261028a600160406000200154610efb565b610f9f565b005b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760003660031901126101c9576005546040516001600160a01b039091168152602090f35b346101c95760003660031901126101c957602060405160008152f35b346101c95760203660031901126101c957610334610e10565b3360009081527fad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5602052604090205460ff16156103eb576001600160a01b0381811680156103d957600580546001600160a01b031981169092179055604080516001600160a01b0393909216831682529190921660208301527fd41ddf0add6cf5f4e7067e117b677c4bf3a6b26973090e908241a081fae54a4b9190819081016101b2565b60405163d92e233d60e01b8152600490fd5b60405163e2517d3f60e01b815233600482015260006024820152604490fd5b346101c95760403660031901126101c957610423610dfa565b600435600052600060205260406000209060018060a01b0316600052602052602060ff604060002054166040519015158152f35b346101c95760003660031901126101c95760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101c95760003660031901126101c9576002546040516001600160a01b039091168152602090f35b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760203660031901126101c957600435610561610e81565b80156105a05760407f46c287b860f967b39d89a1692e6486d60e4d66ea2cde369816239edaf4e0656991600454908060045582519182526020820152a1005b6040516354a62ce560e01b8152600490fd5b346101c95760003660031901126101c9576020600454604051908152f35b346101c95760603660031901126101c95760243567ffffffffffffffff81116101c957366023820112156101c95767ffffffffffffffff8160040135116101c957366024826004013560051b830101116101c9576044356001600160a01b038116908190036101c957600260015414610bba5760026001556004548060043510610b9a575015610b4457806004013515610b88576040516323b872dd60e01b60208201523360248201523060448201526004356064820152606481528060a081011067ffffffffffffffff60a083011117610b2e5760a081016040526106df907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166113f0565b6106ea600435611062565b6040516060810160018060a01b037f000000000000000000000000000000000000000000000000000000000000000016825260043560208301526060604083015282600401359052608081016024830160005b84600401358110610b5657847fc8efbc392b57771291983f003bd32ae9dc5e87ff1388a259b9acf272db4531d885850386a13015610b44576107828160040135611318565b61078f6040519182611014565b6004820135808252601f19906107a490611318565b0136602083013760405180604081011067ffffffffffffffff604083011117610b2e57604081016040526001815260203681830137805115610b18577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316602082015260005b836004013581106109135750508051826004013581036108f1575060005b826004013581106108415760018055005b61084b8183610e26565b5161085860035482611373565b8181116108d457600192916108ce916108c4906108a2816001600160a01b0361089161088c8960048e013560248f01610e3a565b610e4a565b16888060a01b036002541690611330565b858060a01b036108bd61088c878b6004013560248d01610e3a565b1692610e5e565b9060443590611330565b01610830565b6044916040519163270c46bf60e01b835260048301526024820152fd5b6044908360405191631aff8a1160e01b83526004830152600401356024820152fd5b6001600160a01b0361093061088c83600488013560248901610e3a565b169081156103d9576040516370a0823160e01b815230600482015291602083602481845afa928315610a8857600093610ae4575b506005546040516333028b9960e01b815260a06004820152855160a4820181905290916001600160a01b031690829060c482019060208901906000905b808210610abf5750506000196024840152507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316604483015230606483015260848201859052602092908290039082906000905af18015610a8857610a94575b506020602491604051928380926370a0823160e01b82523060048301525afa908115610a8857600091610a55575b50600192610a4491610e5e565b610a4e8286610e26565b5201610812565b90506020813d602011610a80575b81610a7060209383611014565b810103126101c957516001610a37565b3d9150610a63565b6040513d6000823e3d90fd5b602090813d8311610ab8575b610aaa8183611014565b810103126101c95786610a09565b503d610aa0565b82516001600160a01b03168452869450602093840193909201916001909101906109a1565b9092506020813d602011610b10575b81610b0060209383611014565b810103126101c957519186610964565b3d9150610af3565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6040516313e6c64360e31b8152600490fd5b90918235906001600160a01b03821682036101c9576001600160a01b039091168152602090810192019060010161073d565b604051633ce287ef60e21b8152600490fd5b604490604051906301959e9f60e51b825260043560048301526024820152fd5b604051633ee5aeb560e01b8152600490fd5b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760403660031901126101c957610c2a610dfa565b336001600160a01b03821603610c465761028f90600435610f9f565b60405163334bd91960e11b8152600490fd5b346101c95760203660031901126101c957600435610c74610e81565b7f0000000000000000000000000000000000000000000000000000000000000000808211610cd5577f7af7c1a20ca2d95ef775c520be0e875415f760d01d8ab209ad45bfe84839d68e604083600354908060035582519182526020820152a1005b604051636cef961f60e11b815260048101929092526024820152604490fd5b346101c95760403660031901126101c95761028f600435610d13610dfa565b90806000526000602052610d2e600160406000200154610efb565b610f21565b346101c95760203660031901126101c95760043560005260006020526020600160406000200154604051908152f35b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760203660031901126101c9576004359063ffffffff60e01b82168092036101c957602091637965db0b60e01b8114908115610de9575b5015158152f35b6301ffc9a760e01b14905083610de2565b602435906001600160a01b03821682036101c957565b600435906001600160a01b03821682036101c957565b8051821015610b185760209160051b010190565b9190811015610b185760051b0190565b356001600160a01b03811681036101c95790565b91908203918211610e6b57565b634e487b7160e01b600052601160045260246000fd5b3360009081527ff6c17da3865d9645546db4630d07c45803fb99f9b61dd452de8de1cd2159d25460205260409020547f51785d261c3b3e8c2cfe2d0e108b9ab2b1fb703ff9e9e49aba4ebdc85c36152b9060ff1615610edd5750565b6044906040519063e2517d3f60e01b82523360048301526024820152fd5b80600052600060205260406000203360005260205260ff6040600020541615610edd5750565b9060009180835282602052604083209160018060a01b03169182845260205260ff60408420541615600014610f9a57808352826020526040832082845260205260408320600160ff198254161790557f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d339380a4600190565b505090565b9060009180835282602052604083209160018060a01b03169182845260205260ff604084205416600014610f9a5780835282602052604083208284526020526040832060ff1981541690557ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b339380a4600190565b90601f8019910116810190811067ffffffffffffffff821117610b2e57604052565b51906001600160a01b03821682036101c957565b908160209103126101c9575180151581036101c95790565b908115611314576040805163e1e6548d60e01b8152926001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811692916020600481888281895afa978815611309576000986112d2575b508388169586156112c3578260249187519283809263c8232bd760e01b82528b878301525afa90811561123b5760009161128e575b5084811690811561127e57865163095ea7b360e01b81526001600160a01b0390911683820190815260208101869052849082908190604001038160008a7f0000000000000000000000000000000000000000000000000000000000000000165af1801561127357918791600093611246575b5060248251809481936254772560e21b835289888401525af194851561123b5760009182966111fb575b5081169687036111cc5750507f34ae61830bdb58e6775b07f85ca1a832e6ea8a2485a6730c4f2399ddb6b9bf8f949596508351928352820152a2565b8551634ccd3caf60e01b81526001600160a01b03808b1693820193845290911660208301529081906040010390fd5b919095508682813d8311611234575b6112148183611014565b8101031261123157508261122782611036565b9101519438611190565b80fd5b503d61120a565b86513d6000823e3d90fd5b61126590863d881161126c575b61125d8183611014565b81019061104a565b5038611166565b503d611253565b87513d6000823e3d90fd5b8651630de1e8a360e41b81528390fd5b90508281813d83116112bc575b6112a58183611014565b810103126101c9576112b690611036565b386110f4565b503d61129b565b50845163130e394160e01b8152fd5b9097508181813d8311611302575b6112ea8183611014565b810103126101c9576112fb90611036565b96386110bf565b503d6112e0565b85513d6000823e3d90fd5b9050565b67ffffffffffffffff8111610b2e5760051b60200190565b60405163a9059cbb60e01b60208201526001600160a01b039290921660248301526044808301939093529181526113719161136c606483611014565b6113f0565b565b9080820290600019818409908280831092039180830392146113e457620f424090828211156113d2577fde8f6cefed634549b62c77574f722e1ac57e23f24d8fd5cb790fb65668c26139940990828211900360fa1b910360061c170290565b60405163227bc15360e01b8152600490fd5b5050620f424091500490565b60018060a01b031690600080826020829451910182865af13d156114a9573d67ffffffffffffffff81116114955760405161144c93929161143b601f8201601f191660200183611014565b8152809260203d92013e5b836114b6565b805190811515918261147a575b50506114625750565b60249060405190635274afe760e01b82526004820152fd5b61148d925060208091830101910161104a565b153880611459565b634e487b7160e01b83526041600452602483fd5b61144c9150606090611446565b906114dd57508051156114cb57805190602001fd5b604051630a12f52160e11b8152600490fd5b81511580611510575b6114ee575090565b604051639996b31560e01b81526001600160a01b039091166004820152602490fd5b50803b156114e656fea2646970667358221220467dd1bdf7de8630c06bd427c02c38eb31b17735c36a436013fef0b76ed8f0d864736f6c634300081800332f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b60003560e01c90816301ffc9a714610da7575080631f52be6414610d62578063248a9ca314610d335780632f2ff15d14610cf4578063331fb00f14610c5857806336568abe14610c115780633c9f23f014610bcc5780634603be6f146105d057806349b40402146105b257806356d1d4a2146105455780635898ec3b1461050057806358a87913146104bb57806361d027b3146104925780637dd38d9a1461045757806391d148541461040a578063a1b2736a1461031b578063a217fddf146102ff578063acfec690146102d6578063ae37f47914610291578063d547741f14610250578063e0dd245714610215578063e80cfa5e146101f7578063eaff4592146101ce5763f0f442601461012757600080fd5b346101c95760203660031901126101c957610140610e10565b610148610e81565b6001600160a01b0381811680156101b757600280546001600160a01b031981169092179055604080516001600160a01b0393909216831682529190921660208301527f4ab5be82436d353e61ca18726e984e561f5c1cc7c6d38b29d2553c790434705a9190819081015b0390a1005b6040516351dc806d60e11b8152600490fd5b600080fd5b346101c95760203660031901126101c95760206101ef600354600435611373565b604051908152f35b346101c95760003660031901126101c9576020600354604051908152f35b346101c95760003660031901126101c95760206040517f51785d261c3b3e8c2cfe2d0e108b9ab2b1fb703ff9e9e49aba4ebdc85c36152b8152f35b346101c95760403660031901126101c95761028f60043561026f610dfa565b9080600052600060205261028a600160406000200154610efb565b610f9f565b005b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760003660031901126101c9576005546040516001600160a01b039091168152602090f35b346101c95760003660031901126101c957602060405160008152f35b346101c95760203660031901126101c957610334610e10565b3360009081527fad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5602052604090205460ff16156103eb576001600160a01b0381811680156103d957600580546001600160a01b031981169092179055604080516001600160a01b0393909216831682529190921660208301527fd41ddf0add6cf5f4e7067e117b677c4bf3a6b26973090e908241a081fae54a4b9190819081016101b2565b60405163d92e233d60e01b8152600490fd5b60405163e2517d3f60e01b815233600482015260006024820152604490fd5b346101c95760403660031901126101c957610423610dfa565b600435600052600060205260406000209060018060a01b0316600052602052602060ff604060002054166040519015158152f35b346101c95760003660031901126101c95760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101c95760003660031901126101c9576002546040516001600160a01b039091168152602090f35b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760203660031901126101c957600435610561610e81565b80156105a05760407f46c287b860f967b39d89a1692e6486d60e4d66ea2cde369816239edaf4e0656991600454908060045582519182526020820152a1005b6040516354a62ce560e01b8152600490fd5b346101c95760003660031901126101c9576020600454604051908152f35b346101c95760603660031901126101c95760243567ffffffffffffffff81116101c957366023820112156101c95767ffffffffffffffff8160040135116101c957366024826004013560051b830101116101c9576044356001600160a01b038116908190036101c957600260015414610bba5760026001556004548060043510610b9a575015610b4457806004013515610b88576040516323b872dd60e01b60208201523360248201523060448201526004356064820152606481528060a081011067ffffffffffffffff60a083011117610b2e5760a081016040526106df907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166113f0565b6106ea600435611062565b6040516060810160018060a01b037f000000000000000000000000000000000000000000000000000000000000000016825260043560208301526060604083015282600401359052608081016024830160005b84600401358110610b5657847fc8efbc392b57771291983f003bd32ae9dc5e87ff1388a259b9acf272db4531d885850386a13015610b44576107828160040135611318565b61078f6040519182611014565b6004820135808252601f19906107a490611318565b0136602083013760405180604081011067ffffffffffffffff604083011117610b2e57604081016040526001815260203681830137805115610b18577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316602082015260005b836004013581106109135750508051826004013581036108f1575060005b826004013581106108415760018055005b61084b8183610e26565b5161085860035482611373565b8181116108d457600192916108ce916108c4906108a2816001600160a01b0361089161088c8960048e013560248f01610e3a565b610e4a565b16888060a01b036002541690611330565b858060a01b036108bd61088c878b6004013560248d01610e3a565b1692610e5e565b9060443590611330565b01610830565b6044916040519163270c46bf60e01b835260048301526024820152fd5b6044908360405191631aff8a1160e01b83526004830152600401356024820152fd5b6001600160a01b0361093061088c83600488013560248901610e3a565b169081156103d9576040516370a0823160e01b815230600482015291602083602481845afa928315610a8857600093610ae4575b506005546040516333028b9960e01b815260a06004820152855160a4820181905290916001600160a01b031690829060c482019060208901906000905b808210610abf5750506000196024840152507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316604483015230606483015260848201859052602092908290039082906000905af18015610a8857610a94575b506020602491604051928380926370a0823160e01b82523060048301525afa908115610a8857600091610a55575b50600192610a4491610e5e565b610a4e8286610e26565b5201610812565b90506020813d602011610a80575b81610a7060209383611014565b810103126101c957516001610a37565b3d9150610a63565b6040513d6000823e3d90fd5b602090813d8311610ab8575b610aaa8183611014565b810103126101c95786610a09565b503d610aa0565b82516001600160a01b03168452869450602093840193909201916001909101906109a1565b9092506020813d602011610b10575b81610b0060209383611014565b810103126101c957519186610964565b3d9150610af3565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6040516313e6c64360e31b8152600490fd5b90918235906001600160a01b03821682036101c9576001600160a01b039091168152602090810192019060010161073d565b604051633ce287ef60e21b8152600490fd5b604490604051906301959e9f60e51b825260043560048301526024820152fd5b604051633ee5aeb560e01b8152600490fd5b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760403660031901126101c957610c2a610dfa565b336001600160a01b03821603610c465761028f90600435610f9f565b60405163334bd91960e11b8152600490fd5b346101c95760203660031901126101c957600435610c74610e81565b7f0000000000000000000000000000000000000000000000000000000000000000808211610cd5577f7af7c1a20ca2d95ef775c520be0e875415f760d01d8ab209ad45bfe84839d68e604083600354908060035582519182526020820152a1005b604051636cef961f60e11b815260048101929092526024820152604490fd5b346101c95760403660031901126101c95761028f600435610d13610dfa565b90806000526000602052610d2e600160406000200154610efb565b610f21565b346101c95760203660031901126101c95760043560005260006020526020600160406000200154604051908152f35b346101c95760003660031901126101c9576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101c95760203660031901126101c9576004359063ffffffff60e01b82168092036101c957602091637965db0b60e01b8114908115610de9575b5015158152f35b6301ffc9a760e01b14905083610de2565b602435906001600160a01b03821682036101c957565b600435906001600160a01b03821682036101c957565b8051821015610b185760209160051b010190565b9190811015610b185760051b0190565b356001600160a01b03811681036101c95790565b91908203918211610e6b57565b634e487b7160e01b600052601160045260246000fd5b3360009081527ff6c17da3865d9645546db4630d07c45803fb99f9b61dd452de8de1cd2159d25460205260409020547f51785d261c3b3e8c2cfe2d0e108b9ab2b1fb703ff9e9e49aba4ebdc85c36152b9060ff1615610edd5750565b6044906040519063e2517d3f60e01b82523360048301526024820152fd5b80600052600060205260406000203360005260205260ff6040600020541615610edd5750565b9060009180835282602052604083209160018060a01b03169182845260205260ff60408420541615600014610f9a57808352826020526040832082845260205260408320600160ff198254161790557f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d339380a4600190565b505090565b9060009180835282602052604083209160018060a01b03169182845260205260ff604084205416600014610f9a5780835282602052604083208284526020526040832060ff1981541690557ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b339380a4600190565b90601f8019910116810190811067ffffffffffffffff821117610b2e57604052565b51906001600160a01b03821682036101c957565b908160209103126101c9575180151581036101c95790565b908115611314576040805163e1e6548d60e01b8152926001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811692916020600481888281895afa978815611309576000986112d2575b508388169586156112c3578260249187519283809263c8232bd760e01b82528b878301525afa90811561123b5760009161128e575b5084811690811561127e57865163095ea7b360e01b81526001600160a01b0390911683820190815260208101869052849082908190604001038160008a7f0000000000000000000000000000000000000000000000000000000000000000165af1801561127357918791600093611246575b5060248251809481936254772560e21b835289888401525af194851561123b5760009182966111fb575b5081169687036111cc5750507f34ae61830bdb58e6775b07f85ca1a832e6ea8a2485a6730c4f2399ddb6b9bf8f949596508351928352820152a2565b8551634ccd3caf60e01b81526001600160a01b03808b1693820193845290911660208301529081906040010390fd5b919095508682813d8311611234575b6112148183611014565b8101031261123157508261122782611036565b9101519438611190565b80fd5b503d61120a565b86513d6000823e3d90fd5b61126590863d881161126c575b61125d8183611014565b81019061104a565b5038611166565b503d611253565b87513d6000823e3d90fd5b8651630de1e8a360e41b81528390fd5b90508281813d83116112bc575b6112a58183611014565b810103126101c9576112b690611036565b386110f4565b503d61129b565b50845163130e394160e01b8152fd5b9097508181813d8311611302575b6112ea8183611014565b810103126101c9576112fb90611036565b96386110bf565b503d6112e0565b85513d6000823e3d90fd5b9050565b67ffffffffffffffff8111610b2e5760051b60200190565b60405163a9059cbb60e01b60208201526001600160a01b039290921660248301526044808301939093529181526113719161136c606483611014565b6113f0565b565b9080820290600019818409908280831092039180830392146113e457620f424090828211156113d2577fde8f6cefed634549b62c77574f722e1ac57e23f24d8fd5cb790fb65668c26139940990828211900360fa1b910360061c170290565b60405163227bc15360e01b8152600490fd5b5050620f424091500490565b60018060a01b031690600080826020829451910182865af13d156114a9573d67ffffffffffffffff81116114955760405161144c93929161143b601f8201601f191660200183611014565b8152809260203d92013e5b836114b6565b805190811515918261147a575b50506114625750565b60249060405190635274afe760e01b82526004820152fd5b61148d925060208091830101910161104a565b153880611459565b634e487b7160e01b83526041600452602483fd5b61144c9150606090611446565b906114dd57508051156114cb57805190602001fd5b604051630a12f52160e11b8152600490fd5b81511580611510575b6114ee575090565b604051639996b31560e01b81526001600160a01b039091166004820152602490fd5b50803b156114e656fea2646970667358221220467dd1bdf7de8630c06bd427c02c38eb31b17735c36a436013fef0b76ed8f0d864736f6c63430008180033",
  "devdoc": {
    "details": "Implements the RewardClaimable interface.      The caller of `compoundRewards` provides dStable (the exchangeAsset). This contract      then claims specified reward tokens earned by the `targetStaticATokenWrapper`.      The net rewards (after treasury fee) are sent to the receiver specified by the caller.      The initially provided dStable is then converted to the DStakeCollateralVault's      default deposit asset and deposited into the vault.",
    "errors": {
      "AccessControlBadConfirmation()": [
        {
          "details": "The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."
        }
      ],
      "AccessControlUnauthorizedAccount(address,bytes32)": [
        {
          "details": "The `account` is missing a role."
        }
      ],
      "AddressEmptyCode(address)": [
        {
          "details": "There's no code at `target` (it is not a contract)."
        }
      ],
      "AddressInsufficientBalance(address)": [
        {
          "details": "The ETH balance of the account is not enough to perform the operation."
        }
      ],
      "FailedInnerCall()": [
        {
          "details": "A call to an address target failed. The target may have reverted."
        }
      ],
      "MathOverflowedMulDiv()": [
        {
          "details": "Muldiv operation overflow."
        }
      ],
      "ReentrancyGuardReentrantCall()": [
        {
          "details": "Unauthorized reentrant call."
        }
      ],
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC20 token failed."
        }
      ]
    },
    "events": {
      "RoleAdminChanged(bytes32,bytes32,bytes32)": {
        "details": "Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."
      },
      "RoleGranted(bytes32,address,address)": {
        "details": "Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."
      },
      "RoleRevoked(bytes32,address,address)": {
        "details": "Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"
      }
    },
    "kind": "dev",
    "methods": {
      "getRoleAdmin(bytes32)": {
        "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
      },
      "getTreasuryFee(uint256)": {
        "details": "Calculates the treasury fee for a given amount",
        "params": {
          "amount": "The amount to calculate the treasury fee for"
        },
        "returns": {
          "_0": "The treasury fee in the same unit as the amount"
        }
      },
      "grantRole(bytes32,address)": {
        "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."
      },
      "hasRole(bytes32,address)": {
        "details": "Returns `true` if `account` has been granted `role`."
      },
      "renounceRole(bytes32,address)": {
        "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."
      },
      "revokeRole(bytes32,address)": {
        "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."
      },
      "setDLendRewardsController(address)": {
        "details": "Only callable by DEFAULT_ADMIN_ROLE.",
        "params": {
          "_newDLendRewardsController": "The address of the new rewards controller."
        }
      },
      "setExchangeThreshold(uint256)": {
        "details": "Sets the minimum threshold for exchange operations",
        "params": {
          "newExchangeThreshold": "New minimum threshold amount"
        }
      },
      "setTreasury(address)": {
        "details": "Sets the treasury address",
        "params": {
          "newTreasury": "The new treasury address"
        }
      },
      "setTreasuryFeeBps(uint256)": {
        "details": "Sets the treasury fee in basis points",
        "params": {
          "newTreasuryFeeBps": "New treasury fee in basis points (100 = 1bps = 0.01%)"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "title": "DStakeRewardManagerDLend",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "compoundRewards(uint256,address[],address)": {
        "notice": "Override to deposit exchangeAsset for wrapper positions before claiming rewards and distribute rewards"
      },
      "setDLendRewardsController(address)": {
        "notice": "Sets the address of the dLEND RewardsController contract."
      }
    },
    "notice": "Manages claiming of dLEND rewards earned by a specific StaticATokenLM wrapper         (associated with a DStakeCollateralVault) and compounds dStable (provided by a caller)         into the DStakeCollateralVault.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 193,
        "contract": "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol:DStakeRewardManagerDLend",
        "label": "_roles",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes32,t_struct(RoleData)188_storage)"
      },
      {
        "astId": 5495,
        "contract": "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol:DStakeRewardManagerDLend",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 96505,
        "contract": "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol:DStakeRewardManagerDLend",
        "label": "treasury",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 96507,
        "contract": "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol:DStakeRewardManagerDLend",
        "label": "treasuryFeeBps",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 96509,
        "contract": "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol:DStakeRewardManagerDLend",
        "label": "exchangeThreshold",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 95912,
        "contract": "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol:DStakeRewardManagerDLend",
        "label": "dLendRewardsController",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(IDLendRewardsController)95897"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IDLendRewardsController)95897": {
        "encoding": "inplace",
        "label": "contract IDLendRewardsController",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_struct(RoleData)188_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct AccessControl.RoleData)",
        "numberOfBytes": "32",
        "value": "t_struct(RoleData)188_storage"
      },
      "t_struct(RoleData)188_storage": {
        "encoding": "inplace",
        "label": "struct AccessControl.RoleData",
        "members": [
          {
            "astId": 185,
            "contract": "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol:DStakeRewardManagerDLend",
            "label": "hasRole",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 187,
            "contract": "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol:DStakeRewardManagerDLend",
            "label": "adminRole",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}