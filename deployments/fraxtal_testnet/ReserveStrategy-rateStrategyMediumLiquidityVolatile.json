{
  "address": "0xcD7302D72ea486073efacd74A18D8f791457827D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IPoolAddressesProvider",
          "name": "provider",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "optimalUsageRatio",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "baseVariableBorrowRate",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "variableRateSlope1",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "variableRateSlope2",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "stableRateSlope1",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "stableRateSlope2",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "baseStableRateOffset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "stableRateExcessOffset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "optimalStableToTotalDebtRatio",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ADDRESSES_PROVIDER",
      "outputs": [
        {
          "internalType": "contract IPoolAddressesProvider",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_EXCESS_USAGE_RATIO",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "OPTIMAL_USAGE_RATIO",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "unbacked",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityAdded",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityTaken",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalStableDebt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalVariableDebt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "averageStableBorrowRate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "reserveFactor",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "reserve",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "aToken",
              "type": "address"
            }
          ],
          "internalType": "struct DataTypes.CalculateInterestRatesParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "calculateInterestRates",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBaseStableBorrowRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBaseVariableBorrowRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getMaxVariableBorrowRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getStableRateExcessOffset",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getStableRateSlope1",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getStableRateSlope2",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVariableRateSlope1",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVariableRateSlope2",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x0fa161c10014403301d75d92d69fdce19c733b04d07a000833e40d149aef7c99",
  "receipt": {
    "to": null,
    "from": "0x53Ae1433Ab4563d7D5a84d27524784837259f105",
    "contractAddress": "0xcD7302D72ea486073efacd74A18D8f791457827D",
    "transactionIndex": 1,
    "gasUsed": "700953",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5a85bd2dde0f87129ea252ae26c2d2e6c7efc0e3ce9221cc73673bbfa5885e15",
    "transactionHash": "0x0fa161c10014403301d75d92d69fdce19c733b04d07a000833e40d149aef7c99",
    "logs": [],
    "blockNumber": 10337748,
    "cumulativeGasUsed": "746907",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xC691F14942B37668C9904b701E3118A133611b3c",
    "400000000000000000000000000",
    "0",
    "30000000000000000000000000",
    "1970000000000000000000000000",
    "0",
    "0",
    "0",
    "0",
    "0"
  ],
  "numDeployments": 1,
  "solcInputHash": "4a6a3ab49a41002471a76f77fc4e04dd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optimalUsageRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseVariableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableRateSlope1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableRateSlope2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableRateSlope1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableRateSlope2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseStableRateOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableRateExcessOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optimalStableToTotalDebtRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ADDRESSES_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EXCESS_USAGE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPTIMAL_USAGE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"unbacked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityTaken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"averageStableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aToken\",\"type\":\"address\"}],\"internalType\":\"struct DataTypes.CalculateInterestRatesParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"calculateInterestRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseStableBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseVariableBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxVariableBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableRateExcessOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableRateSlope1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableRateSlope2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVariableRateSlope1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVariableRateSlope2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Aave\",\"details\":\"The model of interest rate is based on 2 slopes, one before the `OPTIMAL_USAGE_RATIO` point of usage and another from that one to 100%. - An instance of this same contract, can't be used across different Aave markets, due to the caching   of the PoolAddressesProvider\",\"kind\":\"dev\",\"methods\":{\"calculateInterestRates((uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,address))\":{\"params\":{\"params\":\"The parameters needed to calculate interest rates\"},\"returns\":{\"_0\":\"liquidityRate The liquidity rate expressed in rays\",\"_1\":\"stableBorrowRate The stable borrow rate expressed in rays\",\"_2\":\"variableBorrowRate The variable borrow rate expressed in rays\"}},\"constructor\":{\"details\":\"Constructor.\",\"params\":{\"baseStableRateOffset\":\"The premium on top of variable rate for base stable borrowing rate\",\"baseVariableBorrowRate\":\"The base variable borrow rate\",\"optimalStableToTotalDebtRatio\":\"The optimal stable debt to total debt ratio of the reserve\",\"optimalUsageRatio\":\"The optimal usage ratio\",\"provider\":\"The address of the PoolAddressesProvider contract\",\"stableRateExcessOffset\":\"The premium on top of stable rate when there stable debt surpass the threshold\",\"stableRateSlope1\":\"The stable rate slope below optimal usage ratio\",\"stableRateSlope2\":\"The stable rate slope above optimal usage ratio\",\"variableRateSlope1\":\"The variable rate slope below optimal usage ratio\",\"variableRateSlope2\":\"The variable rate slope above optimal usage ratio\"}},\"getBaseStableBorrowRate()\":{\"returns\":{\"_0\":\"The base stable borrow rate, expressed in ray\"}},\"getBaseVariableBorrowRate()\":{\"returns\":{\"_0\":\"The base variable borrow rate, expressed in ray\"}},\"getMaxVariableBorrowRate()\":{\"returns\":{\"_0\":\"The maximum variable borrow rate, expressed in ray\"}},\"getStableRateExcessOffset()\":{\"details\":\"It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\",\"returns\":{\"_0\":\"The stable rate excess offset, expressed in ray\"}},\"getStableRateSlope1()\":{\"details\":\"It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\",\"returns\":{\"_0\":\"The stable rate slope, expressed in ray\"}},\"getStableRateSlope2()\":{\"details\":\"It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\",\"returns\":{\"_0\":\"The stable rate slope, expressed in ray\"}},\"getVariableRateSlope1()\":{\"details\":\"It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\",\"returns\":{\"_0\":\"The variable rate slope, expressed in ray\"}},\"getVariableRateSlope2()\":{\"details\":\"It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\",\"returns\":{\"_0\":\"The variable rate slope, expressed in ray\"}}},\"stateVariables\":{\"ADDRESSES_PROVIDER\":{\"return\":\"The address of the PoolAddressesProvider contract\",\"returns\":{\"_0\":\"The address of the PoolAddressesProvider contract\"}},\"MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO\":{\"details\":\"It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)\",\"return\":\"The max excess stable to total debt ratio, expressed in ray.\",\"returns\":{\"_0\":\"The max excess stable to total debt ratio, expressed in ray.\"}},\"MAX_EXCESS_USAGE_RATIO\":{\"details\":\"It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)\",\"return\":\"The max excess usage ratio, expressed in ray.\",\"returns\":{\"_0\":\"The max excess usage ratio, expressed in ray.\"}},\"OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\":{\"return\":\"The optimal stable to total debt ratio, expressed in ray.\",\"returns\":{\"_0\":\"The optimal stable to total debt ratio, expressed in ray.\"}},\"OPTIMAL_USAGE_RATIO\":{\"return\":\"The optimal usage ratio, expressed in ray.\",\"returns\":{\"_0\":\"The optimal usage ratio, expressed in ray.\"}}},\"title\":\"DefaultReserveInterestRateStrategy contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"ADDRESSES_PROVIDER()\":{\"notice\":\"Returns the address of the PoolAddressesProvider\"},\"MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO()\":{\"notice\":\"Returns the excess stable debt ratio above the optimal.\"},\"MAX_EXCESS_USAGE_RATIO()\":{\"notice\":\"Returns the excess usage ratio above the optimal.\"},\"OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO()\":{\"notice\":\"Returns the optimal stable to total debt ratio of the reserve.\"},\"OPTIMAL_USAGE_RATIO()\":{\"notice\":\"Returns the usage ratio at which the pool aims to obtain most competitive borrow rates.\"},\"calculateInterestRates((uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,address))\":{\"notice\":\"Calculates the interest rates depending on the reserve's state and configurations\"},\"getBaseStableBorrowRate()\":{\"notice\":\"Returns the base stable borrow rate\"},\"getBaseVariableBorrowRate()\":{\"notice\":\"Returns the base variable borrow rate\"},\"getMaxVariableBorrowRate()\":{\"notice\":\"Returns the maximum variable borrow rate\"},\"getStableRateExcessOffset()\":{\"notice\":\"Returns the stable rate excess offset\"},\"getStableRateSlope1()\":{\"notice\":\"Returns the stable rate slope below optimal usage ratio\"},\"getStableRateSlope2()\":{\"notice\":\"Returns the stable rate slope above optimal usage ratio\"},\"getVariableRateSlope1()\":{\"notice\":\"Returns the variable rate slope below optimal usage ratio\"},\"getVariableRateSlope2()\":{\"notice\":\"Returns the variable rate slope above optimal usage ratio\"}},\"notice\":\"Implements the calculation of the interest rates depending on the reserve state\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lending/core/protocol/pool/DefaultReserveInterestRateStrategy.sol\":\"DefaultReserveInterestRateStrategy\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/lending/core/dependencies/openzeppelin/contracts/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\",\"keccak256\":\"0x9f865ae3d19d19b2ed680009d6a83ae7fdd80594a86fccf567523d68760a648e\",\"license\":\"AGPL-3.0\"},\"contracts/lending/core/interfaces/IDefaultInterestRateStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IReserveInterestRateStrategy} from \\\"./IReserveInterestRateStrategy.sol\\\";\\nimport {IPoolAddressesProvider} from \\\"./IPoolAddressesProvider.sol\\\";\\n\\n/**\\n * @title IDefaultInterestRateStrategy\\n * @author Aave\\n * @notice Defines the basic interface of the DefaultReserveInterestRateStrategy\\n */\\ninterface IDefaultInterestRateStrategy is IReserveInterestRateStrategy {\\n    /**\\n     * @notice Returns the usage ratio at which the pool aims to obtain most competitive borrow rates.\\n     * @return The optimal usage ratio, expressed in ray.\\n     */\\n    function OPTIMAL_USAGE_RATIO() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the optimal stable to total debt ratio of the reserve.\\n     * @return The optimal stable to total debt ratio, expressed in ray.\\n     */\\n    function OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO()\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns the excess usage ratio above the optimal.\\n     * @dev It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)\\n     * @return The max excess usage ratio, expressed in ray.\\n     */\\n    function MAX_EXCESS_USAGE_RATIO() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the excess stable debt ratio above the optimal.\\n     * @dev It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)\\n     * @return The max excess stable to total debt ratio, expressed in ray.\\n     */\\n    function MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO()\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns the address of the PoolAddressesProvider\\n     * @return The address of the PoolAddressesProvider contract\\n     */\\n    function ADDRESSES_PROVIDER()\\n        external\\n        view\\n        returns (IPoolAddressesProvider);\\n\\n    /**\\n     * @notice Returns the variable rate slope below optimal usage ratio\\n     * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\\n     * @return The variable rate slope, expressed in ray\\n     */\\n    function getVariableRateSlope1() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the variable rate slope above optimal usage ratio\\n     * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\\n     * @return The variable rate slope, expressed in ray\\n     */\\n    function getVariableRateSlope2() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the stable rate slope below optimal usage ratio\\n     * @dev It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\\n     * @return The stable rate slope, expressed in ray\\n     */\\n    function getStableRateSlope1() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the stable rate slope above optimal usage ratio\\n     * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\\n     * @return The stable rate slope, expressed in ray\\n     */\\n    function getStableRateSlope2() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the stable rate excess offset\\n     * @dev It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\\n     * @return The stable rate excess offset, expressed in ray\\n     */\\n    function getStableRateExcessOffset() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the base stable borrow rate\\n     * @return The base stable borrow rate, expressed in ray\\n     */\\n    function getBaseStableBorrowRate() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the base variable borrow rate\\n     * @return The base variable borrow rate, expressed in ray\\n     */\\n    function getBaseVariableBorrowRate() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the maximum variable borrow rate\\n     * @return The maximum variable borrow rate, expressed in ray\\n     */\\n    function getMaxVariableBorrowRate() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xe54f0fd2f63fb39eee4b89fa9614d5bb2004a2c14013ede8f616678ba76a14fd\",\"license\":\"AGPL-3.0\"},\"contracts/lending/core/interfaces/IPoolAddressesProvider.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPoolAddressesProvider\\n * @author Aave\\n * @notice Defines the basic interface for a Pool Addresses Provider.\\n */\\ninterface IPoolAddressesProvider {\\n    /**\\n     * @dev Emitted when the market identifier is updated.\\n     * @param oldMarketId The old id of the market\\n     * @param newMarketId The new id of the market\\n     */\\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\\n\\n    /**\\n     * @dev Emitted when the pool is updated.\\n     * @param oldAddress The old address of the Pool\\n     * @param newAddress The new address of the Pool\\n     */\\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @dev Emitted when the pool configurator is updated.\\n     * @param oldAddress The old address of the PoolConfigurator\\n     * @param newAddress The new address of the PoolConfigurator\\n     */\\n    event PoolConfiguratorUpdated(\\n        address indexed oldAddress,\\n        address indexed newAddress\\n    );\\n\\n    /**\\n     * @dev Emitted when the price oracle is updated.\\n     * @param oldAddress The old address of the PriceOracle\\n     * @param newAddress The new address of the PriceOracle\\n     */\\n    event PriceOracleUpdated(\\n        address indexed oldAddress,\\n        address indexed newAddress\\n    );\\n\\n    /**\\n     * @dev Emitted when the ACL manager is updated.\\n     * @param oldAddress The old address of the ACLManager\\n     * @param newAddress The new address of the ACLManager\\n     */\\n    event ACLManagerUpdated(\\n        address indexed oldAddress,\\n        address indexed newAddress\\n    );\\n\\n    /**\\n     * @dev Emitted when the ACL admin is updated.\\n     * @param oldAddress The old address of the ACLAdmin\\n     * @param newAddress The new address of the ACLAdmin\\n     */\\n    event ACLAdminUpdated(\\n        address indexed oldAddress,\\n        address indexed newAddress\\n    );\\n\\n    /**\\n     * @dev Emitted when the price oracle sentinel is updated.\\n     * @param oldAddress The old address of the PriceOracleSentinel\\n     * @param newAddress The new address of the PriceOracleSentinel\\n     */\\n    event PriceOracleSentinelUpdated(\\n        address indexed oldAddress,\\n        address indexed newAddress\\n    );\\n\\n    /**\\n     * @dev Emitted when the pool data provider is updated.\\n     * @param oldAddress The old address of the PoolDataProvider\\n     * @param newAddress The new address of the PoolDataProvider\\n     */\\n    event PoolDataProviderUpdated(\\n        address indexed oldAddress,\\n        address indexed newAddress\\n    );\\n\\n    /**\\n     * @dev Emitted when a new proxy is created.\\n     * @param id The identifier of the proxy\\n     * @param proxyAddress The address of the created proxy contract\\n     * @param implementationAddress The address of the implementation contract\\n     */\\n    event ProxyCreated(\\n        bytes32 indexed id,\\n        address indexed proxyAddress,\\n        address indexed implementationAddress\\n    );\\n\\n    /**\\n     * @dev Emitted when a new non-proxied contract address is registered.\\n     * @param id The identifier of the contract\\n     * @param oldAddress The address of the old contract\\n     * @param newAddress The address of the new contract\\n     */\\n    event AddressSet(\\n        bytes32 indexed id,\\n        address indexed oldAddress,\\n        address indexed newAddress\\n    );\\n\\n    /**\\n     * @dev Emitted when the implementation of the proxy registered with id is updated\\n     * @param id The identifier of the contract\\n     * @param proxyAddress The address of the proxy contract\\n     * @param oldImplementationAddress The address of the old implementation contract\\n     * @param newImplementationAddress The address of the new implementation contract\\n     */\\n    event AddressSetAsProxy(\\n        bytes32 indexed id,\\n        address indexed proxyAddress,\\n        address oldImplementationAddress,\\n        address indexed newImplementationAddress\\n    );\\n\\n    /**\\n     * @notice Returns the id of the Aave market to which this contract points to.\\n     * @return The market id\\n     */\\n    function getMarketId() external view returns (string memory);\\n\\n    /**\\n     * @notice Associates an id with a specific PoolAddressesProvider.\\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\\n     * identify and validate multiple Aave markets.\\n     * @param newMarketId The market id\\n     */\\n    function setMarketId(string calldata newMarketId) external;\\n\\n    /**\\n     * @notice Returns an address by its identifier.\\n     * @dev The returned address might be an EOA or a contract, potentially proxied\\n     * @dev It returns ZERO if there is no registered address with the given id\\n     * @param id The id\\n     * @return The address of the registered for the specified id\\n     */\\n    function getAddressFromID(bytes32 id) external view returns (address);\\n\\n    /**\\n     * @notice General function to update the implementation of a proxy registered with\\n     * certain `id`. If there is no proxy registered, it will instantiate one and\\n     * set as implementation the `newImplementationAddress`.\\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\\n     * setter function, in order to avoid unexpected consequences\\n     * @param id The id\\n     * @param newImplementationAddress The address of the new implementation\\n     */\\n    function setAddressAsProxy(\\n        bytes32 id,\\n        address newImplementationAddress\\n    ) external;\\n\\n    /**\\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\\n     * @param id The id\\n     * @param newAddress The address to set\\n     */\\n    function setAddress(bytes32 id, address newAddress) external;\\n\\n    /**\\n     * @notice Returns the address of the Pool proxy.\\n     * @return The Pool proxy address\\n     */\\n    function getPool() external view returns (address);\\n\\n    /**\\n     * @notice Updates the implementation of the Pool, or creates a proxy\\n     * setting the new `pool` implementation when the function is called for the first time.\\n     * @param newPoolImpl The new Pool implementation\\n     */\\n    function setPoolImpl(address newPoolImpl) external;\\n\\n    /**\\n     * @notice Returns the address of the PoolConfigurator proxy.\\n     * @return The PoolConfigurator proxy address\\n     */\\n    function getPoolConfigurator() external view returns (address);\\n\\n    /**\\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\\n     */\\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\\n\\n    /**\\n     * @notice Returns the address of the price oracle.\\n     * @return The address of the PriceOracle\\n     */\\n    function getPriceOracle() external view returns (address);\\n\\n    /**\\n     * @notice Updates the address of the price oracle.\\n     * @param newPriceOracle The address of the new PriceOracle\\n     */\\n    function setPriceOracle(address newPriceOracle) external;\\n\\n    /**\\n     * @notice Returns the address of the ACL manager.\\n     * @return The address of the ACLManager\\n     */\\n    function getACLManager() external view returns (address);\\n\\n    /**\\n     * @notice Updates the address of the ACL manager.\\n     * @param newAclManager The address of the new ACLManager\\n     */\\n    function setACLManager(address newAclManager) external;\\n\\n    /**\\n     * @notice Returns the address of the ACL admin.\\n     * @return The address of the ACL admin\\n     */\\n    function getACLAdmin() external view returns (address);\\n\\n    /**\\n     * @notice Updates the address of the ACL admin.\\n     * @param newAclAdmin The address of the new ACL admin\\n     */\\n    function setACLAdmin(address newAclAdmin) external;\\n\\n    /**\\n     * @notice Returns the address of the price oracle sentinel.\\n     * @return The address of the PriceOracleSentinel\\n     */\\n    function getPriceOracleSentinel() external view returns (address);\\n\\n    /**\\n     * @notice Updates the address of the price oracle sentinel.\\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\\n     */\\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\\n\\n    /**\\n     * @notice Returns the address of the data provider.\\n     * @return The address of the DataProvider\\n     */\\n    function getPoolDataProvider() external view returns (address);\\n\\n    /**\\n     * @notice Updates the address of the data provider.\\n     * @param newDataProvider The address of the new DataProvider\\n     */\\n    function setPoolDataProvider(address newDataProvider) external;\\n}\\n\",\"keccak256\":\"0xe77d8d5059b52bb94bf1c3cd9a7a1da1e10ace934ce1ff18b4322206f7dc592a\",\"license\":\"AGPL-3.0\"},\"contracts/lending/core/interfaces/IReserveInterestRateStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {DataTypes} from \\\"../protocol/libraries/types/DataTypes.sol\\\";\\n\\n/**\\n * @title IReserveInterestRateStrategy\\n * @author Aave\\n * @notice Interface for the calculation of the interest rates\\n */\\ninterface IReserveInterestRateStrategy {\\n    /**\\n     * @notice Calculates the interest rates depending on the reserve's state and configurations\\n     * @param params The parameters needed to calculate interest rates\\n     * @return liquidityRate The liquidity rate expressed in rays\\n     * @return stableBorrowRate The stable borrow rate expressed in rays\\n     * @return variableBorrowRate The variable borrow rate expressed in rays\\n     */\\n    function calculateInterestRates(\\n        DataTypes.CalculateInterestRatesParams memory params\\n    ) external view returns (uint256, uint256, uint256);\\n}\\n\",\"keccak256\":\"0xae982e5054f5d1a89b015aa411d6dfbf79981a6336d77cecaf32d14e2e08e36c\",\"license\":\"AGPL-3.0\"},\"contracts/lending/core/protocol/libraries/helpers/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Errors library\\n * @author Aave\\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\\n */\\nlibrary Errors {\\n    string public constant CALLER_NOT_POOL_ADMIN = \\\"1\\\"; // 'The caller of the function is not a pool admin'\\n    string public constant CALLER_NOT_EMERGENCY_ADMIN = \\\"2\\\"; // 'The caller of the function is not an emergency admin'\\n    string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = \\\"3\\\"; // 'The caller of the function is not a pool or emergency admin'\\n    string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = \\\"4\\\"; // 'The caller of the function is not a risk or pool admin'\\n    string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = \\\"5\\\"; // 'The caller of the function is not an asset listing or pool admin'\\n    string public constant CALLER_NOT_BRIDGE = \\\"6\\\"; // 'The caller of the function is not a bridge'\\n    string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = \\\"7\\\"; // 'Pool addresses provider is not registered'\\n    string public constant INVALID_ADDRESSES_PROVIDER_ID = \\\"8\\\"; // 'Invalid id for the pool addresses provider'\\n    string public constant NOT_CONTRACT = \\\"9\\\"; // 'Address is not a contract'\\n    string public constant CALLER_NOT_POOL_CONFIGURATOR = \\\"10\\\"; // 'The caller of the function is not the pool configurator'\\n    string public constant CALLER_NOT_ATOKEN = \\\"11\\\"; // 'The caller of the function is not an AToken'\\n    string public constant INVALID_ADDRESSES_PROVIDER = \\\"12\\\"; // 'The address of the pool addresses provider is invalid'\\n    string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = \\\"13\\\"; // 'Invalid return value of the flashloan executor function'\\n    string public constant RESERVE_ALREADY_ADDED = \\\"14\\\"; // 'Reserve has already been added to reserve list'\\n    string public constant NO_MORE_RESERVES_ALLOWED = \\\"15\\\"; // 'Maximum amount of reserves in the pool reached'\\n    string public constant EMODE_CATEGORY_RESERVED = \\\"16\\\"; // 'Zero eMode category is reserved for volatile heterogeneous assets'\\n    string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = \\\"17\\\"; // 'Invalid eMode category assignment to asset'\\n    string public constant RESERVE_LIQUIDITY_NOT_ZERO = \\\"18\\\"; // 'The liquidity of the reserve needs to be 0'\\n    string public constant FLASHLOAN_PREMIUM_INVALID = \\\"19\\\"; // 'Invalid flashloan premium'\\n    string public constant INVALID_RESERVE_PARAMS = \\\"20\\\"; // 'Invalid risk parameters for the reserve'\\n    string public constant INVALID_EMODE_CATEGORY_PARAMS = \\\"21\\\"; // 'Invalid risk parameters for the eMode category'\\n    string public constant BRIDGE_PROTOCOL_FEE_INVALID = \\\"22\\\"; // 'Invalid bridge protocol fee'\\n    string public constant CALLER_MUST_BE_POOL = \\\"23\\\"; // 'The caller of this function must be a pool'\\n    string public constant INVALID_MINT_AMOUNT = \\\"24\\\"; // 'Invalid amount to mint'\\n    string public constant INVALID_BURN_AMOUNT = \\\"25\\\"; // 'Invalid amount to burn'\\n    string public constant INVALID_AMOUNT = \\\"26\\\"; // 'Amount must be greater than 0'\\n    string public constant RESERVE_INACTIVE = \\\"27\\\"; // 'Action requires an active reserve'\\n    string public constant RESERVE_FROZEN = \\\"28\\\"; // 'Action cannot be performed because the reserve is frozen'\\n    string public constant RESERVE_PAUSED = \\\"29\\\"; // 'Action cannot be performed because the reserve is paused'\\n    string public constant BORROWING_NOT_ENABLED = \\\"30\\\"; // 'Borrowing is not enabled'\\n    string public constant STABLE_BORROWING_NOT_ENABLED = \\\"31\\\"; // 'Stable borrowing is not enabled'\\n    string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = \\\"32\\\"; // 'User cannot withdraw more than the available balance'\\n    string public constant INVALID_INTEREST_RATE_MODE_SELECTED = \\\"33\\\"; // 'Invalid interest rate mode selected'\\n    string public constant COLLATERAL_BALANCE_IS_ZERO = \\\"34\\\"; // 'The collateral balance is 0'\\n    string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD =\\n        \\\"35\\\"; // 'Health factor is lesser than the liquidation threshold'\\n    string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = \\\"36\\\"; // 'There is not enough collateral to cover a new borrow'\\n    string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = \\\"37\\\"; // 'Collateral is (mostly) the same currency that is being borrowed'\\n    string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \\\"38\\\"; // 'The requested amount is greater than the max loan size in stable rate mode'\\n    string public constant NO_DEBT_OF_SELECTED_TYPE = \\\"39\\\"; // 'For repayment of a specific type of debt, the user needs to have debt that type'\\n    string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \\\"40\\\"; // 'To repay on behalf of a user an explicit amount to repay is needed'\\n    string public constant NO_OUTSTANDING_STABLE_DEBT = \\\"41\\\"; // 'User does not have outstanding stable rate debt on this reserve'\\n    string public constant NO_OUTSTANDING_VARIABLE_DEBT = \\\"42\\\"; // 'User does not have outstanding variable rate debt on this reserve'\\n    string public constant UNDERLYING_BALANCE_ZERO = \\\"43\\\"; // 'The underlying balance needs to be greater than 0'\\n    string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \\\"44\\\"; // 'Interest rate rebalance conditions were not met'\\n    string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \\\"45\\\"; // 'Health factor is not below the threshold'\\n    string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = \\\"46\\\"; // 'The collateral chosen cannot be liquidated'\\n    string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \\\"47\\\"; // 'User did not borrow the specified currency'\\n    string public constant INCONSISTENT_FLASHLOAN_PARAMS = \\\"49\\\"; // 'Inconsistent flashloan parameters'\\n    string public constant BORROW_CAP_EXCEEDED = \\\"50\\\"; // 'Borrow cap is exceeded'\\n    string public constant SUPPLY_CAP_EXCEEDED = \\\"51\\\"; // 'Supply cap is exceeded'\\n    string public constant UNBACKED_MINT_CAP_EXCEEDED = \\\"52\\\"; // 'Unbacked mint cap is exceeded'\\n    string public constant DEBT_CEILING_EXCEEDED = \\\"53\\\"; // 'Debt ceiling is exceeded'\\n    string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = \\\"54\\\"; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\\n    string public constant STABLE_DEBT_NOT_ZERO = \\\"55\\\"; // 'Stable debt supply is not zero'\\n    string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = \\\"56\\\"; // 'Variable debt supply is not zero'\\n    string public constant LTV_VALIDATION_FAILED = \\\"57\\\"; // 'Ltv validation failed'\\n    string public constant INCONSISTENT_EMODE_CATEGORY = \\\"58\\\"; // 'Inconsistent eMode category'\\n    string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = \\\"59\\\"; // 'Price oracle sentinel validation failed'\\n    string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = \\\"60\\\"; // 'Asset is not borrowable in isolation mode'\\n    string public constant RESERVE_ALREADY_INITIALIZED = \\\"61\\\"; // 'Reserve has already been initialized'\\n    string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO = \\\"62\\\"; // 'User is in isolation mode or ltv is zero'\\n    string public constant INVALID_LTV = \\\"63\\\"; // 'Invalid ltv parameter for the reserve'\\n    string public constant INVALID_LIQ_THRESHOLD = \\\"64\\\"; // 'Invalid liquidity threshold parameter for the reserve'\\n    string public constant INVALID_LIQ_BONUS = \\\"65\\\"; // 'Invalid liquidity bonus parameter for the reserve'\\n    string public constant INVALID_DECIMALS = \\\"66\\\"; // 'Invalid decimals parameter of the underlying asset of the reserve'\\n    string public constant INVALID_RESERVE_FACTOR = \\\"67\\\"; // 'Invalid reserve factor parameter for the reserve'\\n    string public constant INVALID_BORROW_CAP = \\\"68\\\"; // 'Invalid borrow cap for the reserve'\\n    string public constant INVALID_SUPPLY_CAP = \\\"69\\\"; // 'Invalid supply cap for the reserve'\\n    string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = \\\"70\\\"; // 'Invalid liquidation protocol fee for the reserve'\\n    string public constant INVALID_EMODE_CATEGORY = \\\"71\\\"; // 'Invalid eMode category for the reserve'\\n    string public constant INVALID_UNBACKED_MINT_CAP = \\\"72\\\"; // 'Invalid unbacked mint cap for the reserve'\\n    string public constant INVALID_DEBT_CEILING = \\\"73\\\"; // 'Invalid debt ceiling for the reserve\\n    string public constant INVALID_RESERVE_INDEX = \\\"74\\\"; // 'Invalid reserve index'\\n    string public constant ACL_ADMIN_CANNOT_BE_ZERO = \\\"75\\\"; // 'ACL admin cannot be set to the zero address'\\n    string public constant INCONSISTENT_PARAMS_LENGTH = \\\"76\\\"; // 'Array parameters that should be equal length are not'\\n    string public constant ZERO_ADDRESS_NOT_VALID = \\\"77\\\"; // 'Zero address not valid'\\n    string public constant INVALID_EXPIRATION = \\\"78\\\"; // 'Invalid expiration'\\n    string public constant INVALID_SIGNATURE = \\\"79\\\"; // 'Invalid signature'\\n    string public constant OPERATION_NOT_SUPPORTED = \\\"80\\\"; // 'Operation not supported'\\n    string public constant DEBT_CEILING_NOT_ZERO = \\\"81\\\"; // 'Debt ceiling is not zero'\\n    string public constant ASSET_NOT_LISTED = \\\"82\\\"; // 'Asset is not listed'\\n    string public constant INVALID_OPTIMAL_USAGE_RATIO = \\\"83\\\"; // 'Invalid optimal usage ratio'\\n    string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = \\\"84\\\"; // 'Invalid optimal stable to total debt ratio'\\n    string public constant UNDERLYING_CANNOT_BE_RESCUED = \\\"85\\\"; // 'The underlying asset cannot be rescued'\\n    string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = \\\"86\\\"; // 'Reserve has already been added to reserve list'\\n    string public constant POOL_ADDRESSES_DO_NOT_MATCH = \\\"87\\\"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\\n    string public constant STABLE_BORROWING_ENABLED = \\\"88\\\"; // 'Stable borrowing is enabled'\\n    string public constant SILOED_BORROWING_VIOLATION = \\\"89\\\"; // 'User is trying to borrow multiple assets including a siloed one'\\n    string public constant RESERVE_DEBT_NOT_ZERO = \\\"90\\\"; // the total debt of the reserve needs to be 0\\n    string public constant FLASHLOAN_DISABLED = \\\"91\\\"; // FlashLoaning for this asset is disabled\\n}\\n\",\"keccak256\":\"0x4a73e341d689ab87c5944cbd8d13b2761454710a5c7fc71f26ca67fe605e9809\",\"license\":\"BUSL-1.1\"},\"contracts/lending/core/protocol/libraries/math/PercentageMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title PercentageMath library\\n * @author Aave\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n */\\nlibrary PercentageMath {\\n    // Maximum percentage factor (100.00%)\\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\\n\\n    // Half percentage factor (50.00%)\\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\\n\\n    /**\\n     * @notice Executes a percentage multiplication\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return result value percentmul percentage\\n     */\\n    function percentMul(\\n        uint256 value,\\n        uint256 percentage\\n    ) internal pure returns (uint256 result) {\\n        // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\\n        assembly {\\n            if iszero(\\n                or(\\n                    iszero(percentage),\\n                    iszero(\\n                        gt(\\n                            value,\\n                            div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)\\n                        )\\n                    )\\n                )\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            result := div(\\n                add(mul(value, percentage), HALF_PERCENTAGE_FACTOR),\\n                PERCENTAGE_FACTOR\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice Executes a percentage division\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return result value percentdiv percentage\\n     */\\n    function percentDiv(\\n        uint256 value,\\n        uint256 percentage\\n    ) internal pure returns (uint256 result) {\\n        // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\\n        assembly {\\n            if or(\\n                iszero(percentage),\\n                iszero(\\n                    iszero(\\n                        gt(\\n                            value,\\n                            div(\\n                                sub(not(0), div(percentage, 2)),\\n                                PERCENTAGE_FACTOR\\n                            )\\n                        )\\n                    )\\n                )\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            result := div(\\n                add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)),\\n                percentage\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xca74deb7d5b6cb30610f2c476c122c03b259a22e6a88ee30ed40bfd241d83d7a\",\"license\":\"BUSL-1.1\"},\"contracts/lending/core/protocol/libraries/math/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @notice Provides functions to perform calculations with Wad and Ray units\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\\n * with 27 digits of precision)\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n */\\nlibrary WadRayMath {\\n    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = 0.5e18;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = 0.5e27;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a*b, in wad\\n     */\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\\n        assembly {\\n            if iszero(\\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_WAD), WAD)\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a/b, in wad\\n     */\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\\n        assembly {\\n            if or(\\n                iszero(b),\\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, WAD), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raymul b\\n     */\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\\n        assembly {\\n            if iszero(\\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_RAY), RAY)\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raydiv b\\n     */\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\\n        assembly {\\n            if or(\\n                iszero(b),\\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, RAY), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @return b = a converted to wad, rounded half up to the nearest wad\\n     */\\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\\n        assembly {\\n            b := div(a, WAD_RAY_RATIO)\\n            let remainder := mod(a, WAD_RAY_RATIO)\\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\\n                b := add(b, 1)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @return b = a converted in ray\\n     */\\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\\n        // to avoid overflow, b/WAD_RAY_RATIO == a\\n        assembly {\\n            b := mul(a, WAD_RAY_RATIO)\\n\\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1f539d6db76b892037f87322067c2d11988260d78eb56e0592a096c064a26ff8\",\"license\":\"BUSL-1.1\"},\"contracts/lending/core/protocol/libraries/types/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary DataTypes {\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        //the liquidity index. Expressed in ray\\n        uint128 liquidityIndex;\\n        //the current supply rate. Expressed in ray\\n        uint128 currentLiquidityRate;\\n        //variable borrow index. Expressed in ray\\n        uint128 variableBorrowIndex;\\n        //the current variable borrow rate. Expressed in ray\\n        uint128 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint128 currentStableBorrowRate;\\n        //timestamp of last update\\n        uint40 lastUpdateTimestamp;\\n        //the id of the reserve. Represents the position in the list of the active reserves\\n        uint16 id;\\n        //aToken address\\n        address aTokenAddress;\\n        //stableDebtToken address\\n        address stableDebtTokenAddress;\\n        //variableDebtToken address\\n        address variableDebtTokenAddress;\\n        //address of the interest rate strategy\\n        address interestRateStrategyAddress;\\n        //the current treasury balance, scaled\\n        uint128 accruedToTreasury;\\n        //the outstanding unbacked aTokens minted through the bridging feature\\n        uint128 unbacked;\\n        //the outstanding debt borrowed against this asset in isolation mode\\n        uint128 isolationModeTotalDebt;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        //bit 0-15: LTV\\n        //bit 16-31: Liq. threshold\\n        //bit 32-47: Liq. bonus\\n        //bit 48-55: Decimals\\n        //bit 56: reserve is active\\n        //bit 57: reserve is frozen\\n        //bit 58: borrowing is enabled\\n        //bit 59: stable rate borrowing enabled\\n        //bit 60: asset is paused\\n        //bit 61: borrowing in isolation mode is enabled\\n        //bit 62: siloed borrowing enabled\\n        //bit 63: flashloaning enabled\\n        //bit 64-79: reserve factor\\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\\n        //bit 152-167 liquidation protocol fee\\n        //bit 168-175 eMode category\\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\n        //bit 252-255 unused\\n\\n        uint256 data;\\n    }\\n\\n    struct UserConfigurationMap {\\n        /**\\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\\n         * asset is borrowed by the user.\\n         */\\n        uint256 data;\\n    }\\n\\n    struct EModeCategory {\\n        // each eMode category has a custom ltv and liquidation threshold\\n        uint16 ltv;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationBonus;\\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\\n        address priceSource;\\n        string label;\\n    }\\n\\n    enum InterestRateMode {\\n        NONE,\\n        STABLE,\\n        VARIABLE\\n    }\\n\\n    struct ReserveCache {\\n        uint256 currScaledVariableDebt;\\n        uint256 nextScaledVariableDebt;\\n        uint256 currPrincipalStableDebt;\\n        uint256 currAvgStableBorrowRate;\\n        uint256 currTotalStableDebt;\\n        uint256 nextAvgStableBorrowRate;\\n        uint256 nextTotalStableDebt;\\n        uint256 currLiquidityIndex;\\n        uint256 nextLiquidityIndex;\\n        uint256 currVariableBorrowIndex;\\n        uint256 nextVariableBorrowIndex;\\n        uint256 currLiquidityRate;\\n        uint256 currVariableBorrowRate;\\n        uint256 reserveFactor;\\n        ReserveConfigurationMap reserveConfiguration;\\n        address aTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        uint40 reserveLastUpdateTimestamp;\\n        uint40 stableDebtLastUpdateTimestamp;\\n    }\\n\\n    struct ExecuteLiquidationCallParams {\\n        uint256 reservesCount;\\n        uint256 debtToCover;\\n        address collateralAsset;\\n        address debtAsset;\\n        address user;\\n        bool receiveAToken;\\n        address priceOracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct ExecuteSupplyParams {\\n        address asset;\\n        uint256 amount;\\n        address onBehalfOf;\\n        uint16 referralCode;\\n    }\\n\\n    struct ExecuteBorrowParams {\\n        address asset;\\n        address user;\\n        address onBehalfOf;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        uint16 referralCode;\\n        bool releaseUnderlying;\\n        uint256 maxStableRateBorrowSizePercent;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct ExecuteRepayParams {\\n        address asset;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        address onBehalfOf;\\n        bool useATokens;\\n    }\\n\\n    struct ExecuteWithdrawParams {\\n        address asset;\\n        uint256 amount;\\n        address to;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n    }\\n\\n    struct ExecuteSetUserEModeParams {\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 categoryId;\\n    }\\n\\n    struct FinalizeTransferParams {\\n        address asset;\\n        address from;\\n        address to;\\n        uint256 amount;\\n        uint256 balanceFromBefore;\\n        uint256 balanceToBefore;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 fromEModeCategory;\\n    }\\n\\n    struct FlashloanParams {\\n        address receiverAddress;\\n        address[] assets;\\n        uint256[] amounts;\\n        uint256[] interestRateModes;\\n        address onBehalfOf;\\n        bytes params;\\n        uint16 referralCode;\\n        uint256 flashLoanPremiumToProtocol;\\n        uint256 flashLoanPremiumTotal;\\n        uint256 maxStableRateBorrowSizePercent;\\n        uint256 reservesCount;\\n        address addressesProvider;\\n        uint8 userEModeCategory;\\n        bool isAuthorizedFlashBorrower;\\n    }\\n\\n    struct FlashloanSimpleParams {\\n        address receiverAddress;\\n        address asset;\\n        uint256 amount;\\n        bytes params;\\n        uint16 referralCode;\\n        uint256 flashLoanPremiumToProtocol;\\n        uint256 flashLoanPremiumTotal;\\n    }\\n\\n    struct FlashLoanRepaymentParams {\\n        uint256 amount;\\n        uint256 totalPremium;\\n        uint256 flashLoanPremiumToProtocol;\\n        address asset;\\n        address receiverAddress;\\n        uint16 referralCode;\\n    }\\n\\n    struct CalculateUserAccountDataParams {\\n        UserConfigurationMap userConfig;\\n        uint256 reservesCount;\\n        address user;\\n        address oracle;\\n        uint8 userEModeCategory;\\n    }\\n\\n    struct ValidateBorrowParams {\\n        ReserveCache reserveCache;\\n        UserConfigurationMap userConfig;\\n        address asset;\\n        address userAddress;\\n        uint256 amount;\\n        InterestRateMode interestRateMode;\\n        uint256 maxStableLoanPercent;\\n        uint256 reservesCount;\\n        address oracle;\\n        uint8 userEModeCategory;\\n        address priceOracleSentinel;\\n        bool isolationModeActive;\\n        address isolationModeCollateralAddress;\\n        uint256 isolationModeDebtCeiling;\\n    }\\n\\n    struct ValidateLiquidationCallParams {\\n        ReserveCache debtReserveCache;\\n        uint256 totalDebt;\\n        uint256 healthFactor;\\n        address priceOracleSentinel;\\n    }\\n\\n    struct CalculateInterestRatesParams {\\n        uint256 unbacked;\\n        uint256 liquidityAdded;\\n        uint256 liquidityTaken;\\n        uint256 totalStableDebt;\\n        uint256 totalVariableDebt;\\n        uint256 averageStableBorrowRate;\\n        uint256 reserveFactor;\\n        address reserve;\\n        address aToken;\\n    }\\n\\n    struct InitReserveParams {\\n        address asset;\\n        address aTokenAddress;\\n        address stableDebtAddress;\\n        address variableDebtAddress;\\n        address interestRateStrategyAddress;\\n        uint16 reservesCount;\\n        uint16 maxNumberReserves;\\n    }\\n}\\n\",\"keccak256\":\"0xb93629c45e8479d3297ce5adf5efb5e8bddedf4caf5c66c3459d595004d56088\",\"license\":\"BUSL-1.1\"},\"contracts/lending/core/protocol/pool/DefaultReserveInterestRateStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.10;\\n\\nimport {IERC20} from \\\"../../dependencies/openzeppelin/contracts/IERC20.sol\\\";\\nimport {WadRayMath} from \\\"../libraries/math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../libraries/math/PercentageMath.sol\\\";\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\nimport {IDefaultInterestRateStrategy} from \\\"../../interfaces/IDefaultInterestRateStrategy.sol\\\";\\nimport {IReserveInterestRateStrategy} from \\\"../../interfaces/IReserveInterestRateStrategy.sol\\\";\\nimport {IPoolAddressesProvider} from \\\"../../interfaces/IPoolAddressesProvider.sol\\\";\\n\\n/**\\n * @title DefaultReserveInterestRateStrategy contract\\n * @author Aave\\n * @notice Implements the calculation of the interest rates depending on the reserve state\\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_USAGE_RATIO`\\n * point of usage and another from that one to 100%.\\n * - An instance of this same contract, can't be used across different Aave markets, due to the caching\\n *   of the PoolAddressesProvider\\n */\\ncontract DefaultReserveInterestRateStrategy is IDefaultInterestRateStrategy {\\n    using WadRayMath for uint256;\\n    using PercentageMath for uint256;\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    uint256 public immutable OPTIMAL_USAGE_RATIO;\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    uint256 public immutable OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO;\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    uint256 public immutable MAX_EXCESS_USAGE_RATIO;\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    uint256 public immutable MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO;\\n\\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\\n\\n    // Base variable borrow rate when usage rate = 0. Expressed in ray\\n    uint256 internal immutable _baseVariableBorrowRate;\\n\\n    // Slope of the variable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO. Expressed in ray\\n    uint256 internal immutable _variableRateSlope1;\\n\\n    // Slope of the variable interest curve when usage ratio > OPTIMAL_USAGE_RATIO. Expressed in ray\\n    uint256 internal immutable _variableRateSlope2;\\n\\n    // Slope of the stable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO. Expressed in ray\\n    uint256 internal immutable _stableRateSlope1;\\n\\n    // Slope of the stable interest curve when usage ratio > OPTIMAL_USAGE_RATIO. Expressed in ray\\n    uint256 internal immutable _stableRateSlope2;\\n\\n    // Premium on top of `_variableRateSlope1` for base stable borrowing rate\\n    uint256 internal immutable _baseStableRateOffset;\\n\\n    // Additional premium applied to stable rate when stable debt surpass `OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO`\\n    uint256 internal immutable _stableRateExcessOffset;\\n\\n    /**\\n     * @dev Constructor.\\n     * @param provider The address of the PoolAddressesProvider contract\\n     * @param optimalUsageRatio The optimal usage ratio\\n     * @param baseVariableBorrowRate The base variable borrow rate\\n     * @param variableRateSlope1 The variable rate slope below optimal usage ratio\\n     * @param variableRateSlope2 The variable rate slope above optimal usage ratio\\n     * @param stableRateSlope1 The stable rate slope below optimal usage ratio\\n     * @param stableRateSlope2 The stable rate slope above optimal usage ratio\\n     * @param baseStableRateOffset The premium on top of variable rate for base stable borrowing rate\\n     * @param stableRateExcessOffset The premium on top of stable rate when there stable debt surpass the threshold\\n     * @param optimalStableToTotalDebtRatio The optimal stable debt to total debt ratio of the reserve\\n     */\\n    constructor(\\n        IPoolAddressesProvider provider,\\n        uint256 optimalUsageRatio,\\n        uint256 baseVariableBorrowRate,\\n        uint256 variableRateSlope1,\\n        uint256 variableRateSlope2,\\n        uint256 stableRateSlope1,\\n        uint256 stableRateSlope2,\\n        uint256 baseStableRateOffset,\\n        uint256 stableRateExcessOffset,\\n        uint256 optimalStableToTotalDebtRatio\\n    ) {\\n        require(\\n            WadRayMath.RAY >= optimalUsageRatio,\\n            Errors.INVALID_OPTIMAL_USAGE_RATIO\\n        );\\n        require(\\n            WadRayMath.RAY >= optimalStableToTotalDebtRatio,\\n            Errors.INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\\n        );\\n        OPTIMAL_USAGE_RATIO = optimalUsageRatio;\\n        MAX_EXCESS_USAGE_RATIO = WadRayMath.RAY - optimalUsageRatio;\\n        OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = optimalStableToTotalDebtRatio;\\n        MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO =\\n            WadRayMath.RAY -\\n            optimalStableToTotalDebtRatio;\\n        ADDRESSES_PROVIDER = provider;\\n        _baseVariableBorrowRate = baseVariableBorrowRate;\\n        _variableRateSlope1 = variableRateSlope1;\\n        _variableRateSlope2 = variableRateSlope2;\\n        _stableRateSlope1 = stableRateSlope1;\\n        _stableRateSlope2 = stableRateSlope2;\\n        _baseStableRateOffset = baseStableRateOffset;\\n        _stableRateExcessOffset = stableRateExcessOffset;\\n    }\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    function getVariableRateSlope1() external view returns (uint256) {\\n        return _variableRateSlope1;\\n    }\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    function getVariableRateSlope2() external view returns (uint256) {\\n        return _variableRateSlope2;\\n    }\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    function getStableRateSlope1() external view returns (uint256) {\\n        return _stableRateSlope1;\\n    }\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    function getStableRateSlope2() external view returns (uint256) {\\n        return _stableRateSlope2;\\n    }\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    function getStableRateExcessOffset() external view returns (uint256) {\\n        return _stableRateExcessOffset;\\n    }\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    function getBaseStableBorrowRate() public view returns (uint256) {\\n        return _variableRateSlope1 + _baseStableRateOffset;\\n    }\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    function getBaseVariableBorrowRate()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _baseVariableBorrowRate;\\n    }\\n\\n    /// @inheritdoc IDefaultInterestRateStrategy\\n    function getMaxVariableBorrowRate()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return\\n            _baseVariableBorrowRate + _variableRateSlope1 + _variableRateSlope2;\\n    }\\n\\n    struct CalcInterestRatesLocalVars {\\n        uint256 availableLiquidity;\\n        uint256 totalDebt;\\n        uint256 currentVariableBorrowRate;\\n        uint256 currentStableBorrowRate;\\n        uint256 currentLiquidityRate;\\n        uint256 borrowUsageRatio;\\n        uint256 supplyUsageRatio;\\n        uint256 stableToTotalDebtRatio;\\n        uint256 availableLiquidityPlusDebt;\\n    }\\n\\n    /// @inheritdoc IReserveInterestRateStrategy\\n    function calculateInterestRates(\\n        DataTypes.CalculateInterestRatesParams memory params\\n    ) public view override returns (uint256, uint256, uint256) {\\n        CalcInterestRatesLocalVars memory vars;\\n\\n        vars.totalDebt = params.totalStableDebt + params.totalVariableDebt;\\n\\n        vars.currentLiquidityRate = 0;\\n        vars.currentVariableBorrowRate = _baseVariableBorrowRate;\\n        vars.currentStableBorrowRate = getBaseStableBorrowRate();\\n\\n        if (vars.totalDebt != 0) {\\n            vars.stableToTotalDebtRatio = params.totalStableDebt.rayDiv(\\n                vars.totalDebt\\n            );\\n            vars.availableLiquidity =\\n                IERC20(params.reserve).balanceOf(params.aToken) +\\n                params.liquidityAdded -\\n                params.liquidityTaken;\\n\\n            vars.availableLiquidityPlusDebt =\\n                vars.availableLiquidity +\\n                vars.totalDebt;\\n            vars.borrowUsageRatio = vars.totalDebt.rayDiv(\\n                vars.availableLiquidityPlusDebt\\n            );\\n            vars.supplyUsageRatio = vars.totalDebt.rayDiv(\\n                vars.availableLiquidityPlusDebt + params.unbacked\\n            );\\n        }\\n\\n        if (vars.borrowUsageRatio > OPTIMAL_USAGE_RATIO) {\\n            uint256 excessBorrowUsageRatio = (vars.borrowUsageRatio -\\n                OPTIMAL_USAGE_RATIO).rayDiv(MAX_EXCESS_USAGE_RATIO);\\n\\n            vars.currentStableBorrowRate +=\\n                _stableRateSlope1 +\\n                _stableRateSlope2.rayMul(excessBorrowUsageRatio);\\n\\n            vars.currentVariableBorrowRate +=\\n                _variableRateSlope1 +\\n                _variableRateSlope2.rayMul(excessBorrowUsageRatio);\\n        } else {\\n            vars.currentStableBorrowRate += _stableRateSlope1\\n                .rayMul(vars.borrowUsageRatio)\\n                .rayDiv(OPTIMAL_USAGE_RATIO);\\n\\n            vars.currentVariableBorrowRate += _variableRateSlope1\\n                .rayMul(vars.borrowUsageRatio)\\n                .rayDiv(OPTIMAL_USAGE_RATIO);\\n        }\\n\\n        if (vars.stableToTotalDebtRatio > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO) {\\n            uint256 excessStableDebtRatio = (vars.stableToTotalDebtRatio -\\n                OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO).rayDiv(\\n                    MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO\\n                );\\n            vars.currentStableBorrowRate += _stableRateExcessOffset.rayMul(\\n                excessStableDebtRatio\\n            );\\n        }\\n\\n        vars.currentLiquidityRate = _getOverallBorrowRate(\\n            params.totalStableDebt,\\n            params.totalVariableDebt,\\n            vars.currentVariableBorrowRate,\\n            params.averageStableBorrowRate\\n        ).rayMul(vars.supplyUsageRatio).percentMul(\\n                PercentageMath.PERCENTAGE_FACTOR - params.reserveFactor\\n            );\\n\\n        return (\\n            vars.currentLiquidityRate,\\n            vars.currentStableBorrowRate,\\n            vars.currentVariableBorrowRate\\n        );\\n    }\\n\\n    /**\\n     * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable\\n     * debt\\n     * @param totalStableDebt The total borrowed from the reserve at a stable rate\\n     * @param totalVariableDebt The total borrowed from the reserve at a variable rate\\n     * @param currentVariableBorrowRate The current variable borrow rate of the reserve\\n     * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\\n     * @return The weighted averaged borrow rate\\n     */\\n    function _getOverallBorrowRate(\\n        uint256 totalStableDebt,\\n        uint256 totalVariableDebt,\\n        uint256 currentVariableBorrowRate,\\n        uint256 currentAverageStableBorrowRate\\n    ) internal pure returns (uint256) {\\n        uint256 totalDebt = totalStableDebt + totalVariableDebt;\\n\\n        if (totalDebt == 0) return 0;\\n\\n        uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(\\n            currentVariableBorrowRate\\n        );\\n\\n        uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(\\n            currentAverageStableBorrowRate\\n        );\\n\\n        uint256 overallBorrowRate = (weightedVariableRate + weightedStableRate)\\n            .rayDiv(totalDebt.wadToRay());\\n\\n        return overallBorrowRate;\\n    }\\n}\\n\",\"keccak256\":\"0x0399a25f4f3fad7fcf076983fe3f7f7f7b4bc9db23d9ca6b6fa0742f0a8f7d94\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x6102003461021757610e6038819003601f8101601f191683016001600160401b0381118482101761021c5783928291604052833961014092839181010312610217578051916001600160a01b038316830361021757602082015190604083015190606084015190608085015160a08601519160c08701519360e088015195610100998a8a015198610120809b01516b033b2e3c9fd0803ce8000000916100be6100a6610232565b6002815261383360f01b602082015282851015610251565b6100e16100c9610232565b60028152610e0d60f21b602082015283851015610251565b8060805282038281116102015760c0528060a05281039081116102015760e0528a52885281526101609182526101809283526101a09384526101c09485526101e095865260405196610ba798896102b98a3960805189818161020a01526106a6015260a05189818161024501526107c6015260c05189818161043201526106eb015260e05189818161054101526108390152518861010d0152518781816101cf0152818161027b015261064f0152518681816101590152818161029c01528181610798015281816108da0152610a3e0152518581816102c60152818161050601526107720152518481816104cb0152818161074301526108ac015251838181610194015261071d01525182610a5f01525181818161049001526108600152f35b634e487b7160e01b600052601160045260246000fd5b600080fd5b634e487b7160e01b600052604160045260246000fd5b60408051919082016001600160401b0381118382101761021c57604052565b156102595750565b6040519062461bcd60e51b82528160208060048301528251908160248401526000935b82851061029f575050604492506000838284010152601f80199101168101030190fd5b848101820151868601604401529381019385935061027c56fe6080604052600436101561001257600080fd5b60003560e01c80630542975c146100f75780630b3429a2146100f257806314e32da4146100ed57806334762ca5146100e857806354c365c6146100e35780636fb92589146100de57806380031e37146100d9578063a5898709146100d4578063a9c622f8146100cf578063acd78686146100ca578063bc626908146100c5578063d5cd7391146100c0578063f4202409146100bb5763fe5fd698146100b657600080fd5b610529565b6104ee565b6104b3565b610478565b610455565b61041a565b610384565b610268565b61022d565b6101f2565b6101b7565b61017c565b610141565b3461013c57600036600319011261013c576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b600080fd5b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c577f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000081018091116102f9577f000000000000000000000000000000000000000000000000000000000000000081018091116102f957602090604051908152f35b610564565b90601f8019910116810190811067ffffffffffffffff82111761032057604052565b634e487b7160e01b600052604160045260246000fd5b60405190610120820182811067ffffffffffffffff82111761032057604052565b60e435906001600160a01b038216820361013c57565b61010435906001600160a01b038216820361013c57565b3461013c5761012036600319011261013c576104166103f96103a4610336565b6004358152602435602082015260443560408201526064356060820152608435608082015260a43560a082015260c43560c08201526103e1610357565b60e08201526103ee61036d565b610100820152610616565b604080519384526020840192909252908201529081906060820190565b0390f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c576020610470610a3c565b604051908152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b634e487b7160e01b600052601160045260246000fd5b919082018092116102f957565b60405190610120820182811067ffffffffffffffff82111761032057604052816101006000918281528260208201528260408201528260608201528260808201528260a08201528260c08201528260e08201520152565b9081602091031261013c575190565b6040513d6000823e3d90fd5b906127109182039182116102f957565b919082039182116102f957565b9061061f610587565b9060608301928351610637608083019182519061057a565b916020850192835260808501946000865260408101967f00000000000000000000000000000000000000000000000000000000000000008852610678610a3c565b9460608301958652805180610905575b505061080a8260c06108016108189782958d60a061081299018c81517f0000000000000000000000000000000000000000000000000000000000000000908181116000146108945750610767916107106106e9610796936107bc9651610609565b7f000000000000000000000000000000000000000000000000000000000000000090610a8a565b9061076e610767610741847f0000000000000000000000000000000000000000000000000000000000000000610ab0565b7f000000000000000000000000000000000000000000000000000000000000000061057a565b825161057a565b90527f0000000000000000000000000000000000000000000000000000000000000000610ab0565b7f000000000000000000000000000000000000000000000000000000000000000061057a565b90525b60e08501517f000000000000000000000000000000000000000000000000000000000000000090818111610824575b50505190518d519060a08a015192610aec565b91015190610ab0565b9201516105f9565b90610b3f565b80935251925191929190565b61085e61083761088b9361088493610609565b7f000000000000000000000000000000000000000000000000000000000000000090610a8a565b7f0000000000000000000000000000000000000000000000000000000000000000610ab0565b8c5161057a565b8b5238806107ee565b6108fe93610767936108d5610767856108d06108d0967f0000000000000000000000000000000000000000000000000000000000000000610ab0565b610a8a565b9052517f0000000000000000000000000000000000000000000000000000000000000000610ab0565b90526107bf565b9261091583946109789451610a8a565b60e082015261093f61093361093360e088015160018060a01b031690565b6001600160a01b031690565b610100868101516040516370a0823160e01b81526001600160a01b03909116600482015294909391602091869190829081906024820190565b03915afa908115610a375761081897610812966109f861080a966109f2610801956109d46109c98e60406109c060c09f9c60c09d600091610a08575b5060208401519061057a565b91015190610609565b808b5282519061057a565b80938a015251916109e58184610a8a565b60a08a01528c519061057a565b90610a8a565b8486015295509750505092610688565b610a2a915060203d602011610a30575b610a2281836102fe565b8101906105de565b386109b4565b503d610a18565b6105ed565b7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000081018091116102f95790565b8160011c906b033b2e3c9fd0803ce80000009081831904811184151761013c5702010490565b816b019d971e4fe8401e7400000019048111158215171561013c576b033b2e3c9fd0803ce800000091026b019d971e4fe8401e74000000010490565b9192818301938484116102f9578415610b3557610b17610b1291610b12610b1d95610b5d565b610ab0565b93610b5d565b81018091116102f9576109f2610b3292610b5d565b90565b5050505050600090565b8161138819048111158215171561013c576127109102611388010490565b90633b9aca00918281029283040361013c5756fea2646970667358221220d6c79becddda24745c679fe066c29063c0845354cbd006fa6bcfa52b47a8f66d64736f6c63430008180033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b60003560e01c80630542975c146100f75780630b3429a2146100f257806314e32da4146100ed57806334762ca5146100e857806354c365c6146100e35780636fb92589146100de57806380031e37146100d9578063a5898709146100d4578063a9c622f8146100cf578063acd78686146100ca578063bc626908146100c5578063d5cd7391146100c0578063f4202409146100bb5763fe5fd698146100b657600080fd5b610529565b6104ee565b6104b3565b610478565b610455565b61041a565b610384565b610268565b61022d565b6101f2565b6101b7565b61017c565b610141565b3461013c57600036600319011261013c576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b600080fd5b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c577f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000081018091116102f9577f000000000000000000000000000000000000000000000000000000000000000081018091116102f957602090604051908152f35b610564565b90601f8019910116810190811067ffffffffffffffff82111761032057604052565b634e487b7160e01b600052604160045260246000fd5b60405190610120820182811067ffffffffffffffff82111761032057604052565b60e435906001600160a01b038216820361013c57565b61010435906001600160a01b038216820361013c57565b3461013c5761012036600319011261013c576104166103f96103a4610336565b6004358152602435602082015260443560408201526064356060820152608435608082015260a43560a082015260c43560c08201526103e1610357565b60e08201526103ee61036d565b610100820152610616565b604080519384526020840192909252908201529081906060820190565b0390f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c576020610470610a3c565b604051908152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461013c57600036600319011261013c5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b634e487b7160e01b600052601160045260246000fd5b919082018092116102f957565b60405190610120820182811067ffffffffffffffff82111761032057604052816101006000918281528260208201528260408201528260608201528260808201528260a08201528260c08201528260e08201520152565b9081602091031261013c575190565b6040513d6000823e3d90fd5b906127109182039182116102f957565b919082039182116102f957565b9061061f610587565b9060608301928351610637608083019182519061057a565b916020850192835260808501946000865260408101967f00000000000000000000000000000000000000000000000000000000000000008852610678610a3c565b9460608301958652805180610905575b505061080a8260c06108016108189782958d60a061081299018c81517f0000000000000000000000000000000000000000000000000000000000000000908181116000146108945750610767916107106106e9610796936107bc9651610609565b7f000000000000000000000000000000000000000000000000000000000000000090610a8a565b9061076e610767610741847f0000000000000000000000000000000000000000000000000000000000000000610ab0565b7f000000000000000000000000000000000000000000000000000000000000000061057a565b825161057a565b90527f0000000000000000000000000000000000000000000000000000000000000000610ab0565b7f000000000000000000000000000000000000000000000000000000000000000061057a565b90525b60e08501517f000000000000000000000000000000000000000000000000000000000000000090818111610824575b50505190518d519060a08a015192610aec565b91015190610ab0565b9201516105f9565b90610b3f565b80935251925191929190565b61085e61083761088b9361088493610609565b7f000000000000000000000000000000000000000000000000000000000000000090610a8a565b7f0000000000000000000000000000000000000000000000000000000000000000610ab0565b8c5161057a565b8b5238806107ee565b6108fe93610767936108d5610767856108d06108d0967f0000000000000000000000000000000000000000000000000000000000000000610ab0565b610a8a565b9052517f0000000000000000000000000000000000000000000000000000000000000000610ab0565b90526107bf565b9261091583946109789451610a8a565b60e082015261093f61093361093360e088015160018060a01b031690565b6001600160a01b031690565b610100868101516040516370a0823160e01b81526001600160a01b03909116600482015294909391602091869190829081906024820190565b03915afa908115610a375761081897610812966109f861080a966109f2610801956109d46109c98e60406109c060c09f9c60c09d600091610a08575b5060208401519061057a565b91015190610609565b808b5282519061057a565b80938a015251916109e58184610a8a565b60a08a01528c519061057a565b90610a8a565b8486015295509750505092610688565b610a2a915060203d602011610a30575b610a2281836102fe565b8101906105de565b386109b4565b503d610a18565b6105ed565b7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000081018091116102f95790565b8160011c906b033b2e3c9fd0803ce80000009081831904811184151761013c5702010490565b816b019d971e4fe8401e7400000019048111158215171561013c576b033b2e3c9fd0803ce800000091026b019d971e4fe8401e74000000010490565b9192818301938484116102f9578415610b3557610b17610b1291610b12610b1d95610b5d565b610ab0565b93610b5d565b81018091116102f9576109f2610b3292610b5d565b90565b5050505050600090565b8161138819048111158215171561013c576127109102611388010490565b90633b9aca00918281029283040361013c5756fea2646970667358221220d6c79becddda24745c679fe066c29063c0845354cbd006fa6bcfa52b47a8f66d64736f6c63430008180033",
  "devdoc": {
    "author": "Aave",
    "details": "The model of interest rate is based on 2 slopes, one before the `OPTIMAL_USAGE_RATIO` point of usage and another from that one to 100%. - An instance of this same contract, can't be used across different Aave markets, due to the caching   of the PoolAddressesProvider",
    "kind": "dev",
    "methods": {
      "calculateInterestRates((uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,address))": {
        "params": {
          "params": "The parameters needed to calculate interest rates"
        },
        "returns": {
          "_0": "liquidityRate The liquidity rate expressed in rays",
          "_1": "stableBorrowRate The stable borrow rate expressed in rays",
          "_2": "variableBorrowRate The variable borrow rate expressed in rays"
        }
      },
      "constructor": {
        "details": "Constructor.",
        "params": {
          "baseStableRateOffset": "The premium on top of variable rate for base stable borrowing rate",
          "baseVariableBorrowRate": "The base variable borrow rate",
          "optimalStableToTotalDebtRatio": "The optimal stable debt to total debt ratio of the reserve",
          "optimalUsageRatio": "The optimal usage ratio",
          "provider": "The address of the PoolAddressesProvider contract",
          "stableRateExcessOffset": "The premium on top of stable rate when there stable debt surpass the threshold",
          "stableRateSlope1": "The stable rate slope below optimal usage ratio",
          "stableRateSlope2": "The stable rate slope above optimal usage ratio",
          "variableRateSlope1": "The variable rate slope below optimal usage ratio",
          "variableRateSlope2": "The variable rate slope above optimal usage ratio"
        }
      },
      "getBaseStableBorrowRate()": {
        "returns": {
          "_0": "The base stable borrow rate, expressed in ray"
        }
      },
      "getBaseVariableBorrowRate()": {
        "returns": {
          "_0": "The base variable borrow rate, expressed in ray"
        }
      },
      "getMaxVariableBorrowRate()": {
        "returns": {
          "_0": "The maximum variable borrow rate, expressed in ray"
        }
      },
      "getStableRateExcessOffset()": {
        "details": "It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO",
        "returns": {
          "_0": "The stable rate excess offset, expressed in ray"
        }
      },
      "getStableRateSlope1()": {
        "details": "It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO",
        "returns": {
          "_0": "The stable rate slope, expressed in ray"
        }
      },
      "getStableRateSlope2()": {
        "details": "It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO",
        "returns": {
          "_0": "The stable rate slope, expressed in ray"
        }
      },
      "getVariableRateSlope1()": {
        "details": "It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO",
        "returns": {
          "_0": "The variable rate slope, expressed in ray"
        }
      },
      "getVariableRateSlope2()": {
        "details": "It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO",
        "returns": {
          "_0": "The variable rate slope, expressed in ray"
        }
      }
    },
    "stateVariables": {
      "ADDRESSES_PROVIDER": {
        "return": "The address of the PoolAddressesProvider contract",
        "returns": {
          "_0": "The address of the PoolAddressesProvider contract"
        }
      },
      "MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO": {
        "details": "It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)",
        "return": "The max excess stable to total debt ratio, expressed in ray.",
        "returns": {
          "_0": "The max excess stable to total debt ratio, expressed in ray."
        }
      },
      "MAX_EXCESS_USAGE_RATIO": {
        "details": "It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)",
        "return": "The max excess usage ratio, expressed in ray.",
        "returns": {
          "_0": "The max excess usage ratio, expressed in ray."
        }
      },
      "OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO": {
        "return": "The optimal stable to total debt ratio, expressed in ray.",
        "returns": {
          "_0": "The optimal stable to total debt ratio, expressed in ray."
        }
      },
      "OPTIMAL_USAGE_RATIO": {
        "return": "The optimal usage ratio, expressed in ray.",
        "returns": {
          "_0": "The optimal usage ratio, expressed in ray."
        }
      }
    },
    "title": "DefaultReserveInterestRateStrategy contract",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "ADDRESSES_PROVIDER()": {
        "notice": "Returns the address of the PoolAddressesProvider"
      },
      "MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO()": {
        "notice": "Returns the excess stable debt ratio above the optimal."
      },
      "MAX_EXCESS_USAGE_RATIO()": {
        "notice": "Returns the excess usage ratio above the optimal."
      },
      "OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO()": {
        "notice": "Returns the optimal stable to total debt ratio of the reserve."
      },
      "OPTIMAL_USAGE_RATIO()": {
        "notice": "Returns the usage ratio at which the pool aims to obtain most competitive borrow rates."
      },
      "calculateInterestRates((uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,address))": {
        "notice": "Calculates the interest rates depending on the reserve's state and configurations"
      },
      "getBaseStableBorrowRate()": {
        "notice": "Returns the base stable borrow rate"
      },
      "getBaseVariableBorrowRate()": {
        "notice": "Returns the base variable borrow rate"
      },
      "getMaxVariableBorrowRate()": {
        "notice": "Returns the maximum variable borrow rate"
      },
      "getStableRateExcessOffset()": {
        "notice": "Returns the stable rate excess offset"
      },
      "getStableRateSlope1()": {
        "notice": "Returns the stable rate slope below optimal usage ratio"
      },
      "getStableRateSlope2()": {
        "notice": "Returns the stable rate slope above optimal usage ratio"
      },
      "getVariableRateSlope1()": {
        "notice": "Returns the variable rate slope below optimal usage ratio"
      },
      "getVariableRateSlope2()": {
        "notice": "Returns the variable rate slope above optimal usage ratio"
      }
    },
    "notice": "Implements the calculation of the interest rates depending on the reserve state",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}